<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8"/>
    <title>RefSCC</title>
        <link rel="stylesheet" type="text/css" href="../../clang-doc-mustache.css"/>
        <script src="../../mustache-index.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="navbar__container">
            <div class="navbar__logo">
                
            </div>
            <div class="navbar__menu">
                <ul class="navbar__links">
                    <li class="navbar__item">
                        <a href="../../index.html" class="navbar__link">Home</a>
                    </li>
                </ul>
            </div>
            <div class="navbar-breadcrumb-container">
                <div class="navbar-breadcrumb-item"><a href="../../GlobalNamespace/index.html">Global Namespace</a></div>&rarr;
                <div class="navbar-breadcrumb-item"><a href="../index.html">llvm</a></div>&rarr;
                <div class="navbar-breadcrumb-item"><a href="../_ZTVN4llvm13LazyCallGraphE.html">LazyCallGraph</a></div>
            </div>
        </div>
    </nav>
    <main>
        <div class="container">
            <div class="sidebar">
                <h2>class RefSCC</h2>
                <ul>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#PublicMethods">Public Method</a>
                    </li>
                    <li>
                        <ul>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E79F1E2A42C163C7A441106FC9CF61B485914F7B">isParentOf</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#CC8D70D22C56FABD92AF3E01EA90D1F588AEE655">isAncestorOf</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#C544621E0A12738A6583067E6FD3E676232EB7CC">switchInternalEdgeToCall</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E8222B00F17E2E43DE9175023DED3AF1420F671A">begin</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0AEBD17391B5FAF4F4D536080425E2EDE7FF79D5">end</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#9B58415581D4F954AC69A3A04462CC679B377F25">size</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#AC5AC0CAEF4C8F69C1BD012985430D601CAF1E1D">operator[]</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8F11D585F1F125937B6ACEC5893F40C76C271439">find</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#98A1E326983B69B01D19F8BAB8963BFB696982CE">isChildOf</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F3801BD137FBB3713451E62DD622F74C64998394">isDescendantOf</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#B1EF0CB807EE180B25628AC845236B80560A0711">getName</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2031EA5FBD0CCE2673DC971762D09A1D3C929D65">switchTrivialInternalEdgeToRef</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#01093DBE851FFFF65F434B49AA22748F7A8E843D">switchInternalEdgeToRef</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0BA2C17DAF1C8F552ED8CE97E72F4CE38E1617B3">switchOutgoingEdgeToCall</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#D4F9C68086E6515DE0823EF1784142A388EAFDFB">switchOutgoingEdgeToRef</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0FD411E6DDF9EA7040ABDA39FB206ACFEECFE642">insertInternalRefEdge</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E5723FF8D88FA13F8D5692529160039D5DCCCF9A">insertOutgoingEdge</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#FAF43CD78B35D48B074DC70BF77BF3472C24895A">insertIncomingRefEdge</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#115C9037A8966C22A119C62AF8CC81A0268E5CD3">removeOutgoingEdge</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#BB79899F4C7F05150E2362D1659AEDC9079CE141">removeInternalRefEdges</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5A45D859960301141D00911838B548A684F0D27E">insertTrivialCallEdge</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8A7063126344B3AA6172F30DED34F25015809D14">insertTrivialRefEdge</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#BECCB1FF9C67EEA79B23DEAA7498A07DEE264755">replaceNodeFunction</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="resizer" id="resizer"></div>
            <div class="content">
                <section class="hero section-container">
                    <div class="hero__title">
                        <h1 class="hero__title-large">class RefSCC</h1>
                        <p>Defined at line 542 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                        <div class="hero__subtitle">
                            <div>
                                <p> A RefSCC of the call graph.</p>
                            </div>
                            <div>
                                <p> This models a Strongly Connected Component of function reference edges in</p>
                                <p> the call graph. As opposed to actual SCCs, these can be used to scope</p>
                                <p> subgraphs of the module which are independent from other subgraphs of the</p>
                                <p> module because they do not reference it in any way. This is also the unit</p>
                                <p> where we do mutation of the graph in order to restrict mutations to those</p>
                                <p> which don&#39;t violate this independence.</p>
                            </div>
                            <div>
                                <p> A RefSCC contains a DAG of actual SCCs. All the nodes within the RefSCC</p>
                                <p> are necessarily within some actual SCC that nests within it. Since</p>
                                <p> a direct call *is* a reference, there will always be at least one RefSCC</p>
                                <p> around any SCC.</p>
                            </div>
                            <div>
                                <p> Spurious ref edges, meaning ref edges that still exist in the call graph</p>
                                <p> even though the corresponding IR reference no longer exists, are allowed.</p>
                                <p> This is mostly to support argument promotion, which can modify a caller to</p>
                                <p> no longer pass a function. The only place that needs to specially handle</p>
                                <p> this is deleting a dead function/node, otherwise the dead ref edges are</p>
                                <p> automatically removed when visiting the function/node no longer containing</p>
                                <p> the ref edge.</p>
                            </div>
                        </div>
                    </div>
                </section>
                <section id="PublicMethods" class="section-container">
                    <h2>Public Methods</h2>
                    <div>
                        <div class="delimiter-container">
                            <div id="E79F1E2A42C163C7A441106FC9CF61B485914F7B">
                                <pre><code class="language-cpp code-clang-doc">bool isParentOf (const RefSCC &amp; RC)</code></pre>
                                <div>
                                    <div>
                                        <p> Test if this RefSCC is a parent of </p>
                                    </div>
                                    <div>
                                        <p> CAUTION: This method walks every edge in the </p>
                                        <p> it can be very</p>
                                        <p> expensive.</p>
                                    </div>
                                </div>
                                <p>Defined at line 410 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="CC8D70D22C56FABD92AF3E01EA90D1F588AEE655">
                                <pre><code class="language-cpp code-clang-doc">bool isAncestorOf (const RefSCC &amp; RC)</code></pre>
                                <div>
                                    <div>
                                        <p> Test if this RefSCC is an ancestor of </p>
                                    </div>
                                    <div>
                                        <p> CAUTION: This method walks the directed graph of edges as far as</p>
                                        <p> necessary to find a possible path to the argument. In the worst case</p>
                                        <p> this may walk the entire graph and can be extremely expensive.</p>
                                    </div>
                                </div>
                                <p>Defined at line 424 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="C544621E0A12738A6583067E6FD3E676232EB7CC">
                                <pre><code class="language-cpp code-clang-doc">bool switchInternalEdgeToCall (Node &amp; SourceN, Node &amp; TargetN, function_ref&lt;void (ArrayRef&lt;SCC *&gt;)&gt; MergeCB)</code></pre>
                                <div>
                                    <div>
                                        <p> Make an existing internal ref edge into a call edge.</p>
                                    </div>
                                    <div>
                                        <p> This may form a larger cycle and thus collapse SCCs into TargetN&#39;s SCC.</p>
                                        <p> If that happens, the optional callback </p>
                                        <p> will be invoked (if</p>
                                        <p> provided) on the SCCs being merged away prior to actually performing</p>
                                        <p> the merge. Note that this will never include the target SCC as that</p>
                                        <p> will be the SCC functions are merged into to resolve the cycle. Once</p>
                                        <p> this function returns, these merged SCCs are not in a valid state but</p>
                                        <p> the pointers will remain valid until destruction of the parent graph</p>
                                        <p> instance for the purpose of clearing cached information. This function</p>
                                        <p> also returns &#39;true&#39; if a cycle was formed and some SCCs merged away as</p>
                                        <p> a convenience.</p>
                                    </div>
                                    <div>
                                        <p> After this operation, both SourceN&#39;s SCC and TargetN&#39;s SCC may move</p>
                                        <p> position within this RefSCC&#39;s postorder list. Any SCCs merged are</p>
                                        <p> merged into the TargetN&#39;s SCC in order to preserve reachability analyses</p>
                                        <p> which took place on that SCC.</p>
                                    </div>
                                </div>
                                <p>Defined at line 586 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E8222B00F17E2E43DE9175023DED3AF1420F671A">
                                <pre><code class="language-cpp code-clang-doc">int begin ()</code></pre>
                                <p>Defined at line 610 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0AEBD17391B5FAF4F4D536080425E2EDE7FF79D5">
                                <pre><code class="language-cpp code-clang-doc">int end ()</code></pre>
                                <p>Defined at line 611 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="9B58415581D4F954AC69A3A04462CC679B377F25">
                                <pre><code class="language-cpp code-clang-doc">ssize_t size ()</code></pre>
                                <p>Defined at line 613 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="AC5AC0CAEF4C8F69C1BD012985430D601CAF1E1D">
                                <pre><code class="language-cpp code-clang-doc">SCC &amp; operator[] (int Idx)</code></pre>
                                <p>Defined at line 615 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8F11D585F1F125937B6ACEC5893F40C76C271439">
                                <pre><code class="language-cpp code-clang-doc">int find (SCC &amp; C)</code></pre>
                                <p>Defined at line 617 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="98A1E326983B69B01D19F8BAB8963BFB696982CE">
                                <pre><code class="language-cpp code-clang-doc">bool isChildOf (const RefSCC &amp; RC)</code></pre>
                                <div>
                                    <div>
                                        <p> Test if this RefSCC is a child of </p>
                                    </div>
                                    <div>
                                        <p> CAUTION: This method walks every edge in the argument </p>
                                        <p> it can</p>
                                        <p> be very expensive.</p>
                                    </div>
                                </div>
                                <p>Defined at line 638 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F3801BD137FBB3713451E62DD622F74C64998394">
                                <pre><code class="language-cpp code-clang-doc">bool isDescendantOf (const RefSCC &amp; RC)</code></pre>
                                <div>
                                    <div>
                                        <p> Test if this RefSCC is a descendant of </p>
                                    </div>
                                    <div>
                                        <p> CAUTION: This method walks the directed graph of edges as far as</p>
                                        <p> necessary to find a possible path from the argument. In the worst case</p>
                                        <p> this may walk the entire graph and can be extremely expensive.</p>
                                    </div>
                                </div>
                                <p>Defined at line 645 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="B1EF0CB807EE180B25628AC845236B80560A0711">
                                <pre><code class="language-cpp code-clang-doc">basic_string getName ()</code></pre>
                                <div>
                                    <div>
                                        <p> Provide a short name by printing this RefSCC to a std::string.</p>
                                    </div>
                                    <div>
                                        <p> This copes with the fact that we don&#39;t have a name per se for an RefSCC</p>
                                        <p> while still making the use of this in debugging and logging useful.</p>
                                    </div>
                                </div>
                                <p>Defined at line 653 of file llvm/include/llvm/Analysis/LazyCallGraph.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2031EA5FBD0CCE2673DC971762D09A1D3C929D65">
                                <pre><code class="language-cpp code-clang-doc">void switchTrivialInternalEdgeToRef (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> Make an existing internal call edge between separate SCCs into a ref</p>
                                        <p> edge.</p>
                                    </div>
                                    <div>
                                        <p> If SourceN and TargetN in separate SCCs within this RefSCC, changing</p>
                                        <p> the call edge between them to a ref edge is a trivial operation that</p>
                                        <p> does not require any structural changes to the call graph.</p>
                                    </div>
                                </div>
                                <p>Defined at line 733 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="01093DBE851FFFF65F434B49AA22748F7A8E843D">
                                <pre><code class="language-cpp code-clang-doc">int switchInternalEdgeToRef (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> Make an existing internal call edge within a single SCC into a ref</p>
                                        <p> edge.</p>
                                    </div>
                                    <div>
                                        <p> Since SourceN and TargetN are part of a single SCC, this SCC may be</p>
                                        <p> split up due to breaking a cycle in the call edges that formed it. If</p>
                                        <p> that happens, then this routine will insert new SCCs into the postorder</p>
                                        <p> list *before* the SCC of TargetN (previously the SCC of both). This</p>
                                        <p> preserves postorder as the TargetN can reach all of the other nodes by</p>
                                        <p> definition of previously being in a single SCC formed by the cycle from</p>
                                        <p> SourceN to TargetN.</p>
                                    </div>
                                    <div>
                                        <p> The newly added SCCs are added *immediately* and contiguously</p>
                                        <p> prior to the TargetN SCC and return the range covering the new SCCs in</p>
                                        <p> the RefSCC&#39;s postorder sequence. You can directly iterate the returned</p>
                                        <p> range to observe all of the new SCCs in postorder.</p>
                                    </div>
                                    <div>
                                        <p> Note that if SourceN and TargetN are in separate SCCs, the simpler</p>
                                        <p> routine `switchTrivialInternalEdgeToRef` should be used instead.</p>
                                    </div>
                                </div>
                                <p>Defined at line 751 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0BA2C17DAF1C8F552ED8CE97E72F4CE38E1617B3">
                                <pre><code class="language-cpp code-clang-doc">void switchOutgoingEdgeToCall (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> Make an existing outgoing ref edge into a call edge.</p>
                                    </div>
                                    <div>
                                        <p> Note that this is trivial as there are no cyclic impacts and there</p>
                                        <p> remains a reference edge.</p>
                                    </div>
                                </div>
                                <p>Defined at line 932 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="D4F9C68086E6515DE0823EF1784142A388EAFDFB">
                                <pre><code class="language-cpp code-clang-doc">void switchOutgoingEdgeToRef (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> Make an existing outgoing call edge into a ref edge.</p>
                                    </div>
                                    <div>
                                        <p> This is trivial as there are no cyclic impacts and there remains</p>
                                        <p> a reference edge.</p>
                                    </div>
                                </div>
                                <p>Defined at line 953 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0FD411E6DDF9EA7040ABDA39FB206ACFEECFE642">
                                <pre><code class="language-cpp code-clang-doc">void insertInternalRefEdge (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> Insert a ref edge from one node in this RefSCC to another in this</p>
                                        <p> RefSCC.</p>
                                    </div>
                                    <div>
                                        <p> This is always a trivial operation as it doesn&#39;t change any part of the</p>
                                        <p> graph structure besides connecting the two nodes.</p>
                                    </div>
                                    <div>
                                        <p> Note that we don&#39;t support directly inserting internal *call* edges</p>
                                        <p> because that could change the graph structure and requires returning</p>
                                        <p> information about what became invalid. As a consequence, the pattern</p>
                                        <p> should be to first insert the necessary ref edge, and then to switch it</p>
                                        <p> to a call edge if needed and handle any invalidation that results. See</p>
                                        <p> the </p>
                                        <p> routine for details.</p>
                                    </div>
                                </div>
                                <p>Defined at line 974 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E5723FF8D88FA13F8D5692529160039D5DCCCF9A">
                                <pre><code class="language-cpp code-clang-doc">void insertOutgoingEdge (Node &amp; SourceN, Node &amp; TargetN, Kind EK)</code></pre>
                                <div>
                                    <div>
                                        <p> Insert an edge whose parent is in this RefSCC and child is in some</p>
                                        <p> child RefSCC.</p>
                                    </div>
                                    <div>
                                        <p> There must be an existing path from the </p>
                                        <p> to the </p>
                                        <p> This operation is inexpensive and does not change the set of SCCs and</p>
                                        <p> RefSCCs in the graph.</p>
                                    </div>
                                </div>
                                <p>Defined at line 986 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="FAF43CD78B35D48B074DC70BF77BF3472C24895A">
                                <pre><code class="language-cpp code-clang-doc">SmallVector&lt;RefSCC *, 1&gt; insertIncomingRefEdge (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> Insert an edge whose source is in a descendant RefSCC and target is in</p>
                                        <p> this RefSCC.</p>
                                    </div>
                                    <div>
                                        <p> There must be an existing path from the target to the source in this</p>
                                        <p> case.</p>
                                    </div>
                                    <div>
                                        <p> NB! This is has the potential to be a very expensive function. It</p>
                                        <p> inherently forms a cycle in the prior RefSCC DAG and we have to merge</p>
                                        <p> RefSCCs to resolve that cycle. But finding all of the RefSCCs which</p>
                                        <p> participate in the cycle can in the worst case require traversing every</p>
                                        <p> RefSCC in the graph. Every attempt is made to avoid that, but passes</p>
                                        <p> must still exercise caution calling this routine repeatedly.</p>
                                    </div>
                                    <div>
                                        <p> Also note that this can only insert ref edges. In order to insert</p>
                                        <p> a call edge, first insert a ref edge and then switch it to a call edge.</p>
                                        <p> These are intentionally kept as separate interfaces because each step</p>
                                        <p> of the operation invalidates a different set of data structures.</p>
                                    </div>
                                    <div>
                                        <p> This returns all the RefSCCs which were merged into the this RefSCC</p>
                                        <p> (the target&#39;s). This allows callers to invalidate any cached</p>
                                        <p> information.</p>
                                    </div>
                                    <div>
                                        <p> FIXME: We could possibly optimize this quite a bit for cases where the</p>
                                        <p> caller and callee are very nearby in the graph. See comments in the</p>
                                        <p> implementation for details, but that use case might impact users.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1005 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="115C9037A8966C22A119C62AF8CC81A0268E5CD3">
                                <pre><code class="language-cpp code-clang-doc">void removeOutgoingEdge (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> Remove an edge whose source is in this RefSCC and target is *not*.</p>
                                    </div>
                                    <div>
                                        <p> This removes an inter-RefSCC edge. All inter-RefSCC edges originating</p>
                                        <p> from this SCC have been fully explored by any in-flight DFS graph</p>
                                        <p> formation, so this is always safe to call once you have the source</p>
                                        <p> RefSCC.</p>
                                    </div>
                                    <div>
                                        <p> This operation does not change the cyclic structure of the graph and so</p>
                                        <p> is very inexpensive. It may change the connectivity graph of the SCCs</p>
                                        <p> though, so be careful calling this while iterating over them.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1147 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="BB79899F4C7F05150E2362D1659AEDC9079CE141">
                                <pre><code class="language-cpp code-clang-doc">SmallVector&lt;RefSCC *, 1&gt; removeInternalRefEdges (ArrayRef&lt;std::pair&lt;Node *, Node *&gt;&gt; Edges)</code></pre>
                                <div>
                                    <div>
                                        <p> Remove a list of ref edges which are entirely within this RefSCC.</p>
                                    </div>
                                    <div>
                                        <p> Both the </p>
                                        <p> and all of the </p>
                                        <p> must be within this</p>
                                        <p> RefSCC. Removing these edges may break cycles that form this RefSCC and</p>
                                        <p> thus this operation may change the RefSCC graph significantly. In</p>
                                        <p> particular, this operation will re-form new RefSCCs based on the</p>
                                        <p> remaining connectivity of the graph. The following invariants are</p>
                                        <p> guaranteed to hold after calling this method:</p>
                                    </div>
                                    <div>
                                        <p> 1) If a ref-cycle remains after removal, it leaves this RefSCC intact</p>
                                        <p>    and in the graph. No new RefSCCs are built.</p>
                                        <p> 2) Otherwise, this RefSCC will be dead after this call and no longer in</p>
                                        <p>    the graph or the postorder traversal of the call graph. Any iterator</p>
                                        <p>    pointing at this RefSCC will become invalid.</p>
                                        <p> 3) All newly formed RefSCCs will be returned and the order of the</p>
                                        <p>    RefSCCs returned will be a valid postorder traversal of the new</p>
                                        <p>    RefSCCs.</p>
                                        <p> 4) No RefSCC other than this RefSCC has its member set changed (this is</p>
                                        <p>    inherent in the definition of removing such an edge).</p>
                                    </div>
                                    <div>
                                        <p> These invariants are very important to ensure that we can build</p>
                                        <p> optimization pipelines on top of the CGSCC pass manager which</p>
                                        <p> intelligently update the RefSCC graph without invalidating other parts</p>
                                        <p> of the RefSCC graph.</p>
                                    </div>
                                    <div>
                                        <p> Note that we provide no routine to remove a *call* edge. Instead, you</p>
                                        <p> must first switch it to a ref edge using </p>
                                        <p> This split API is intentional as each of these two steps can invalidate</p>
                                        <p> a different aspect of the graph structure and needs to have the</p>
                                        <p> invalidation handled independently.</p>
                                    </div>
                                    <div>
                                        <p> The runtime complexity of this method is, in the worst case, O(V+E)</p>
                                        <p> where V is the number of nodes in this RefSCC and E is the number of</p>
                                        <p> edges leaving the nodes in this RefSCC. Note that E includes both edges</p>
                                        <p> within this RefSCC and edges from this RefSCC to child RefSCCs. Some</p>
                                        <p> effort has been made to minimize the overhead of common cases such as</p>
                                        <p> self-edges and edge removals which result in a spanning tree with no</p>
                                        <p> more cycles.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1164 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5A45D859960301141D00911838B548A684F0D27E">
                                <pre><code class="language-cpp code-clang-doc">void insertTrivialCallEdge (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> A convenience wrapper around the above to handle trivial cases of</p>
                                        <p> inserting a new call edge.</p>
                                    </div>
                                    <div>
                                        <p> This is trivial whenever the target is in the same SCC as the source or</p>
                                        <p> the edge is an outgoing edge to some descendant SCC. In these cases</p>
                                        <p> there is no change to the cyclic structure of SCCs or RefSCCs.</p>
                                    </div>
                                    <div>
                                        <p> To further make calling this convenient, it also handles inserting</p>
                                        <p> already existing edges.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1395 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8A7063126344B3AA6172F30DED34F25015809D14">
                                <pre><code class="language-cpp code-clang-doc">void insertTrivialRefEdge (Node &amp; SourceN, Node &amp; TargetN)</code></pre>
                                <div>
                                    <div>
                                        <p> A convenience wrapper around the above to handle trivial cases of</p>
                                        <p> inserting a new ref edge.</p>
                                    </div>
                                    <div>
                                        <p> This is trivial whenever the target is in the same RefSCC as the source</p>
                                        <p> or the edge is an outgoing edge to some descendant RefSCC. In these</p>
                                        <p> cases there is no change to the cyclic structure of the RefSCCs.</p>
                                    </div>
                                    <div>
                                        <p> To further make calling this convenient, it also handles inserting</p>
                                        <p> already existing edges.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1424 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="BECCB1FF9C67EEA79B23DEAA7498A07DEE264755">
                                <pre><code class="language-cpp code-clang-doc">void replaceNodeFunction (Node &amp; N, Function &amp; NewF)</code></pre>
                                <div>
                                    <div>
                                        <p> Directly replace a node&#39;s function with a new function.</p>
                                    </div>
                                    <div>
                                        <p> This should be used when moving the body and users of a function to</p>
                                        <p> a new formal function object but not otherwise changing the call graph</p>
                                        <p> structure in any way.</p>
                                    </div>
                                    <div>
                                        <p> It requires that the old function in the provided node have zero uses</p>
                                        <p> and the new function must have calls and references to it establishing</p>
                                        <p> an equivalent graph.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1448 of file llvm/lib/Analysis/LazyCallGraph.cpp</p>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </main>
</body>
</html>

<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8"/>
    <title>HashBuilder</title>
        <link rel="stylesheet" type="text/css" href="../clang-doc-mustache.css"/>
        <script src="../mustache-index.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="navbar__container">
            <div class="navbar__logo">
                
            </div>
            <div class="navbar__menu">
                <ul class="navbar__links">
                    <li class="navbar__item">
                        <a href="../index.html" class="navbar__link">Home</a>
                    </li>
                </ul>
            </div>
            <div class="navbar-breadcrumb-container">
                <div class="navbar-breadcrumb-item"><a href="../GlobalNamespace/index.html">Global Namespace</a></div>&rarr;
                <div class="navbar-breadcrumb-item"><a href="./index.html">llvm</a></div>
            </div>
        </div>
    </nav>
    <main>
        <div class="container">
            <div class="sidebar">
                <h2>class HashBuilder</h2>
                <ul>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#PublicMethods">Public Method</a>
                    </li>
                    <li>
                        <ul>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#64AF271027619EF74F3FAB93AC4DDD6F1FD5902A">HashBuilder&lt;HasherT, Endianness&gt;</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#692A042A10AD51BD3CB53AD4A0E76BB19783B845">HashBuilder&lt;HasherT, Endianness&gt;</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F54D6584E7854548C1D595B3EE5212CAC6165A91">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#74BF1B1D35A753D4E01578C9B6D9EBE390B3C4AC">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#3F8CA8B1386127ADDC447BAE8BE945E55B394222">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#796B8A666FF35E28F7E8BA383C415A5758F680F1">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#B441DB2E11F92601CDC77BE1B76B707E519CDB97">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#BEF9BB5DCCEE29398375F29D630FED1159E89BB1">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#577F605003CDEA6A35FF022137C52D6B7908DDFD">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2C1A825BB0F9B0B4A5033FF998D3EE29FFC2C74E">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8504AF96D5DD7DAA8770DA85989939FAC2BFA77E">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#02B525FB4F28AD7CC195FA3EFB4A0EC6E3FD7BEB">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5E2C66F7D9C4ADB0E01BE22EECB7334DFB6D5EA5">add</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6DE11CD07169F35585B89204213C286098CD1626">addRange</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#7C8C407D05884AE7385331B3B9E3AF2A55AE4E0D">addRange</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#25C40B3FB754C32F8937656046917DD8C954BE3A">addRangeElements</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#69620D7A77455BD723D3DB37CF5F2E82F6BFD5DD">addRangeElements</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#A4B02CD61247479AF11882773B339B4FF6D5B835">adjustForEndiannessAndAdd</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1D57F5E81E00E96C94EFDBDF5D74E67C6EAFAE25">adjustForEndiannessAndAdd</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="resizer" id="resizer"></div>
            <div class="content">
                <section class="hero section-container">
                    <pre><code class="language-cpp code-clang-doc">template &lt;typename HasherT, llvm::endianness Endianness&gt;</code></pre>
                    <div class="hero__title">
                        <h1 class="hero__title-large">class HashBuilder</h1>
                        <p>Defined at line 137 of file llvm/include/llvm/Support/HashBuilder.h</p>
                        <div class="hero__subtitle">
                            <div>
                                <p> Interface to help hash various types through a hasher type.</p>
                            </div>
                            <div>
                                <p> Via provided specializations of `add`, `addRange`, and `addRangeElements`</p>
                                <p> functions, various types (e.g. `ArrayRef`, `StringRef`, etc.) can be hashed</p>
                                <p> without requiring any knowledge of hashed types from the hasher type.</p>
                            </div>
                            <div>
                                <p> The only method expected from the templated hasher type `HasherT` is:</p>
                                <p> * void update(ArrayRef</p>
                                <p>&lt;uint8</p>
                                <p>_t&gt; Data)</p>
                            </div>
                            <div>
                                <p> Additionally, the following methods will be forwarded to the hasher type:</p>
                                <p> * decltype(std::declval</p>
                                <p>&lt;HasherT</p>
                                <p>&amp;</p>
                                <p>&gt;().final()) final()</p>
                                <p> * decltype(std::declval</p>
                                <p>&lt;HasherT</p>
                                <p>&amp;</p>
                                <p>&gt;().result()) result()</p>
                            </div>
                            <div>
                                <p> From a user point of view, the interface provides the following:</p>
                                <p> * `template</p>
                                <p>&lt;typename</p>
                                <p> T&gt; add(const T </p>
                                <p>&amp;Value</p>
                                <p>)`</p>
                                <p>   The `add` function implements hashing of various types.</p>
                                <p> * `template </p>
                                <p>&lt;typename</p>
                                <p> ItT&gt; void addRange(ItT First, ItT Last)`</p>
                                <p>   The `addRange` function is designed to aid hashing a range of values.</p>
                                <p>   It explicitly adds the size of the range in the hash.</p>
                                <p> * `template </p>
                                <p>&lt;typename</p>
                                <p> ItT&gt; void addRangeElements(ItT First, ItT Last)`</p>
                                <p>   The `addRangeElements` function is also designed to aid hashing a range of</p>
                                <p>   values. In contrast to `addRange`, it **ignores** the size of the range,</p>
                                <p>   behaving as if elements were added one at a time with `add`.</p>
                            </div>
                            <div>
                                <p> User-defined `struct` types can participate in this interface by providing</p>
                                <p> an `addHash` templated function. See the associated template specialization</p>
                                <p> for details.</p>
                            </div>
                            <div>
                                <p> This interface does not impose requirements on the hasher</p>
                                <p> `update(ArrayRef</p>
                                <p>&lt;uint8</p>
                                <p>_t&gt; Data)` method. We want to avoid collisions for</p>
                                <p> variable-size types; for example for</p>
                                <p> ```</p>
                                <p> builder.add({1});</p>
                                <p> builder.add({2, 3});</p>
                                <p> ```</p>
                                <p> and</p>
                                <p> ```</p>
                                <p> builder.add({1, 2});</p>
                                <p> builder.add({3});</p>
                                <p> ```</p>
                                <p> . Thus, specializations of `add` and `addHash` for variable-size types must</p>
                                <p> not assume that the hasher type considers the size as part of the hash; they</p>
                                <p> must explicitly add the size to the hash. See for example specializations</p>
                                <p> for `ArrayRef` and `StringRef`.</p>
                            </div>
                            <div>
                                <p> Additionally, since types are eventually forwarded to the hasher&#39;s</p>
                                <p> `void update(ArrayRef</p>
                                <p>&lt;uint8</p>
                                <p>_t&gt;)` method, endianness plays a role in the hash</p>
                                <p> computation (for example when computing `add((int)123)`).</p>
                                <p> Specifiying a non-`native` `Endianness` template parameter allows to compute</p>
                                <p> stable hash across platforms with different endianness.</p>
                            </div>
                        </div>
                    </div>
                </section>
                <section id="PublicMethods" class="section-container">
                    <h2>Public Methods</h2>
                    <div>
                        <div class="delimiter-container">
                            <div id="64AF271027619EF74F3FAB93AC4DDD6F1FD5902A">
                                <pre><code class="language-cpp code-clang-doc">void HashBuilder&lt;HasherT, Endianness&gt; (HasherT &amp; Hasher)</code></pre>
                                <p>Defined at line 139 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="692A042A10AD51BD3CB53AD4A0E76BB19783B845">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename... ArgTypes&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">void HashBuilder&lt;HasherT, Endianness&gt; (ArgTypes &amp;&amp;... Args)</code></pre>
                                <p>Defined at line 141 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F54D6584E7854548C1D595B3EE5212CAC6165A91">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">std::enable_if_t&lt;hashbuilder_detail::IsHashableData&lt;T&gt;::value, HashBuilder&lt;HasherT, Endianness&gt; &amp;&gt; add (T Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Implement hashing for hashable data types, e.g. integral or enum values.</p>
                                    </div>
                                </div>
                                <p>Defined at line 146 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="74BF1B1D35A753D4E01578C9B6D9EBE390B3C4AC">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">int add (T Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Implement hashing for hashable data types, e.g. integral or enum values.</p>
                                    </div>
                                </div>
                                <p>Defined at line 146 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="3F8CA8B1386127ADDC447BAE8BE945E55B394222">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">HashBuilder&lt;HasherT, Endianness&gt; &amp; add (ArrayRef&lt;T&gt; Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Support hashing `ArrayRef`.</p>
                                    </div>
                                    <div>
                                        <p> `Value.size()` is taken into account to ensure cases like</p>
                                        <p> ```</p>
                                        <p> builder.add({1});</p>
                                        <p> builder.add({2, 3});</p>
                                        <p> ```</p>
                                        <p> and</p>
                                        <p> ```</p>
                                        <p> builder.add({1, 2});</p>
                                        <p> builder.add({3});</p>
                                        <p> ```</p>
                                        <p> do not collide.</p>
                                    </div>
                                </div>
                                <p>Defined at line 164 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="796B8A666FF35E28F7E8BA383C415A5758F680F1">
                                <pre><code class="language-cpp code-clang-doc">HashBuilder&lt;HasherT, Endianness&gt; &amp; add (StringRef Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Support hashing `StringRef`.</p>
                                    </div>
                                    <div>
                                        <p> `Value.size()` is taken into account to ensure cases like</p>
                                        <p> ```</p>
                                        <p> builder.add(&quot;a&quot;);</p>
                                        <p> builder.add(&quot;bc&quot;);</p>
                                        <p> ```</p>
                                        <p> and</p>
                                        <p> ```</p>
                                        <p> builder.add(&quot;ab&quot;);</p>
                                        <p> builder.add(&quot;c&quot;);</p>
                                        <p> ```</p>
                                        <p> do not collide.</p>
                                    </div>
                                </div>
                                <p>Defined at line 194 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="B441DB2E11F92601CDC77BE1B76B707E519CDB97">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">std::enable_if_t&lt;is_detected&lt;HasAddHashT, T&gt;::value &amp;&amp; !hashbuilder_detail::IsHashableData&lt;T&gt;::value, HashBuilder&lt;HasherT, Endianness&gt; &amp;&gt; add (const T &amp; Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Implement hashing for user-defined `struct`s.</p>
                                    </div>
                                    <div>
                                        <p> Any user-define `struct` can participate in hashing via `HashBuilder` by</p>
                                        <p> providing a `addHash` templated function.</p>
                                    </div>
                                    <div>
                                        <p> ```</p>
                                        <p> template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p> void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>              const UserDefinedStruct </p>
                                        <p>&amp;Value</p>
                                        <p>);</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> For example:</p>
                                        <p> ```</p>
                                        <p> struct SimpleStruct {</p>
                                        <p>   char c;</p>
                                        <p>   int i;</p>
                                        <p> };</p>
                                    </div>
                                    <div>
                                        <p> template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p> void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>              const SimpleStruct </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>   HBuilder.add(Value.c);</p>
                                        <p>   HBuilder.add(Value.i);</p>
                                        <p> }</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> To avoid endianness issues, specializations of `addHash` should</p>
                                        <p> generally rely on exising `add`, `addRange`, and `addRangeElements`</p>
                                        <p> functions. If directly using `update`, an implementation must correctly</p>
                                        <p> handle endianness.</p>
                                    </div>
                                    <div>
                                        <p> ```</p>
                                        <p> struct __attribute__ ((packed)) StructWithFastHash {</p>
                                        <p>   int I;</p>
                                        <p>   char C;</p>
                                    </div>
                                    <div>
                                        <p>   // If possible, we want to hash both `I` and `C` in a single</p>
                                        <p>   // `update` call for performance concerns.</p>
                                        <p>   template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p>   friend void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>                       const StructWithFastHash </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>     if (Endianness == llvm::endianness::native) {</p>
                                        <p>       HBuilder.update(ArrayRef(</p>
                                        <p>           reinterpret_cast</p>
                                        <p>&lt;const</p>
                                        <p> uint8_t *&gt;(</p>
                                        <p>&amp;Value</p>
                                        <p>), sizeof(Value)));</p>
                                        <p>     } else {</p>
                                        <p>       // Rely on existing `add` methods to handle endianness.</p>
                                        <p>       HBuilder.add(Value.I);</p>
                                        <p>       HBuilder.add(Value.C);</p>
                                        <p>     }</p>
                                        <p>   }</p>
                                        <p> };</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> To avoid collisions, specialization of `addHash` for variable-size</p>
                                        <p> types must take the size into account.</p>
                                    </div>
                                    <div>
                                        <p> For example:</p>
                                        <p> ```</p>
                                        <p> struct CustomContainer {</p>
                                        <p> private:</p>
                                        <p>   size_t Size;</p>
                                        <p>   int Elements[100];</p>
                                    </div>
                                    <div>
                                        <p> public:</p>
                                        <p>   CustomContainer(size_t Size) : Size(Size) {</p>
                                        <p>     for (size_t I = 0; I != Size; ++I)</p>
                                        <p>       Elements[I] = I;</p>
                                        <p>   }</p>
                                        <p>   template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p>   friend void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>                       const CustomContainer </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>     if (Endianness == llvm::endianness::native) {</p>
                                        <p>       HBuilder.update(ArrayRef(</p>
                                        <p>           reinterpret_cast</p>
                                        <p>&lt;const</p>
                                        <p> uint8_t *&gt;(</p>
                                        <p>&amp;Value</p>
                                        <p>.Size),</p>
                                        <p>           sizeof(Value.Size) + Value.Size * sizeof(Value.Elements[0])));</p>
                                        <p>     } else {</p>
                                        <p>       // `addRange` will take care of encoding the size.</p>
                                        <p>       HBuilder.addRange(</p>
                                        <p>&amp;Value</p>
                                        <p>.Elements[0], </p>
                                        <p>&amp;Value</p>
                                        <p>.Elements[0] +</p>
                                        <p>       Value.Size);</p>
                                        <p>     }</p>
                                        <p>   }</p>
                                        <p> };</p>
                                        <p> ```</p>
                                    </div>
                                </div>
                                <p>Defined at line 292 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="BEF9BB5DCCEE29398375F29D630FED1159E89BB1">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">int add (const T &amp; Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Implement hashing for user-defined `struct`s.</p>
                                    </div>
                                    <div>
                                        <p> Any user-define `struct` can participate in hashing via `HashBuilder` by</p>
                                        <p> providing a `addHash` templated function.</p>
                                    </div>
                                    <div>
                                        <p> ```</p>
                                        <p> template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p> void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>              const UserDefinedStruct </p>
                                        <p>&amp;Value</p>
                                        <p>);</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> For example:</p>
                                        <p> ```</p>
                                        <p> struct SimpleStruct {</p>
                                        <p>   char c;</p>
                                        <p>   int i;</p>
                                        <p> };</p>
                                    </div>
                                    <div>
                                        <p> template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p> void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>              const SimpleStruct </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>   HBuilder.add(Value.c);</p>
                                        <p>   HBuilder.add(Value.i);</p>
                                        <p> }</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> To avoid endianness issues, specializations of `addHash` should</p>
                                        <p> generally rely on exising `add`, `addRange`, and `addRangeElements`</p>
                                        <p> functions. If directly using `update`, an implementation must correctly</p>
                                        <p> handle endianness.</p>
                                    </div>
                                    <div>
                                        <p> ```</p>
                                        <p> struct __attribute__ ((packed)) StructWithFastHash {</p>
                                        <p>   int I;</p>
                                        <p>   char C;</p>
                                    </div>
                                    <div>
                                        <p>   // If possible, we want to hash both `I` and `C` in a single</p>
                                        <p>   // `update` call for performance concerns.</p>
                                        <p>   template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p>   friend void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>                       const StructWithFastHash </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>     if (Endianness == llvm::endianness::native) {</p>
                                        <p>       HBuilder.update(ArrayRef(</p>
                                        <p>           reinterpret_cast</p>
                                        <p>&lt;const</p>
                                        <p> uint8_t *&gt;(</p>
                                        <p>&amp;Value</p>
                                        <p>), sizeof(Value)));</p>
                                        <p>     } else {</p>
                                        <p>       // Rely on existing `add` methods to handle endianness.</p>
                                        <p>       HBuilder.add(Value.I);</p>
                                        <p>       HBuilder.add(Value.C);</p>
                                        <p>     }</p>
                                        <p>   }</p>
                                        <p> };</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> To avoid collisions, specialization of `addHash` for variable-size</p>
                                        <p> types must take the size into account.</p>
                                    </div>
                                    <div>
                                        <p> For example:</p>
                                        <p> ```</p>
                                        <p> struct CustomContainer {</p>
                                        <p> private:</p>
                                        <p>   size_t Size;</p>
                                        <p>   int Elements[100];</p>
                                    </div>
                                    <div>
                                        <p> public:</p>
                                        <p>   CustomContainer(size_t Size) : Size(Size) {</p>
                                        <p>     for (size_t I = 0; I != Size; ++I)</p>
                                        <p>       Elements[I] = I;</p>
                                        <p>   }</p>
                                        <p>   template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p>   friend void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>                       const CustomContainer </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>     if (Endianness == llvm::endianness::native) {</p>
                                        <p>       HBuilder.update(ArrayRef(</p>
                                        <p>           reinterpret_cast</p>
                                        <p>&lt;const</p>
                                        <p> uint8_t *&gt;(</p>
                                        <p>&amp;Value</p>
                                        <p>.Size),</p>
                                        <p>           sizeof(Value.Size) + Value.Size * sizeof(Value.Elements[0])));</p>
                                        <p>     } else {</p>
                                        <p>       // `addRange` will take care of encoding the size.</p>
                                        <p>       HBuilder.addRange(</p>
                                        <p>&amp;Value</p>
                                        <p>.Elements[0], </p>
                                        <p>&amp;Value</p>
                                        <p>.Elements[0] +</p>
                                        <p>       Value.Size);</p>
                                        <p>     }</p>
                                        <p>   }</p>
                                        <p> };</p>
                                        <p> ```</p>
                                    </div>
                                </div>
                                <p>Defined at line 292 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="577F605003CDEA6A35FF022137C52D6B7908DDFD">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">std::enable_if_t&lt;is_detected&lt;HasAddHashT, T&gt;::value &amp;&amp; ! hashbuilder_detail::IsHashableData&lt;T&gt;::value, HashBuilder&lt;HasherT, Endianness&gt; &amp;&gt; add (const T &amp; Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Implement hashing for user-defined `struct`s.</p>
                                    </div>
                                    <div>
                                        <p> Any user-define `struct` can participate in hashing via `HashBuilder` by</p>
                                        <p> providing a `addHash` templated function.</p>
                                    </div>
                                    <div>
                                        <p> ```</p>
                                        <p> template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p> void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>              const UserDefinedStruct </p>
                                        <p>&amp;Value</p>
                                        <p>);</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> For example:</p>
                                        <p> ```</p>
                                        <p> struct SimpleStruct {</p>
                                        <p>   char c;</p>
                                        <p>   int i;</p>
                                        <p> };</p>
                                    </div>
                                    <div>
                                        <p> template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p> void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>              const SimpleStruct </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>   HBuilder.add(Value.c);</p>
                                        <p>   HBuilder.add(Value.i);</p>
                                        <p> }</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> To avoid endianness issues, specializations of `addHash` should</p>
                                        <p> generally rely on exising `add`, `addRange`, and `addRangeElements`</p>
                                        <p> functions. If directly using `update`, an implementation must correctly</p>
                                        <p> handle endianness.</p>
                                    </div>
                                    <div>
                                        <p> ```</p>
                                        <p> struct __attribute__ ((packed)) StructWithFastHash {</p>
                                        <p>   int I;</p>
                                        <p>   char C;</p>
                                    </div>
                                    <div>
                                        <p>   // If possible, we want to hash both `I` and `C` in a single</p>
                                        <p>   // `update` call for performance concerns.</p>
                                        <p>   template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p>   friend void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>                       const StructWithFastHash </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>     if (Endianness == llvm::endianness::native) {</p>
                                        <p>       HBuilder.update(ArrayRef(</p>
                                        <p>           reinterpret_cast</p>
                                        <p>&lt;const</p>
                                        <p> uint8_t *&gt;(</p>
                                        <p>&amp;Value</p>
                                        <p>), sizeof(Value)));</p>
                                        <p>     } else {</p>
                                        <p>       // Rely on existing `add` methods to handle endianness.</p>
                                        <p>       HBuilder.add(Value.I);</p>
                                        <p>       HBuilder.add(Value.C);</p>
                                        <p>     }</p>
                                        <p>   }</p>
                                        <p> };</p>
                                        <p> ```</p>
                                    </div>
                                    <div>
                                        <p> To avoid collisions, specialization of `addHash` for variable-size</p>
                                        <p> types must take the size into account.</p>
                                    </div>
                                    <div>
                                        <p> For example:</p>
                                        <p> ```</p>
                                        <p> struct CustomContainer {</p>
                                        <p> private:</p>
                                        <p>   size_t Size;</p>
                                        <p>   int Elements[100];</p>
                                    </div>
                                    <div>
                                        <p> public:</p>
                                        <p>   CustomContainer(size_t Size) : Size(Size) {</p>
                                        <p>     for (size_t I = 0; I != Size; ++I)</p>
                                        <p>       Elements[I] = I;</p>
                                        <p>   }</p>
                                        <p>   template </p>
                                        <p>&lt;typename</p>
                                        <p> HasherT, llvm::endianness Endianness&gt;</p>
                                        <p>   friend void addHash(HashBuilder</p>
                                        <p>&lt;HasherT</p>
                                        <p>, Endianness&gt; </p>
                                        <p>&amp;HBuilder</p>
                                        <p>,</p>
                                        <p>                       const CustomContainer </p>
                                        <p>&amp;Value</p>
                                        <p>) {</p>
                                        <p>     if (Endianness == llvm::endianness::native) {</p>
                                        <p>       HBuilder.update(ArrayRef(</p>
                                        <p>           reinterpret_cast</p>
                                        <p>&lt;const</p>
                                        <p> uint8_t *&gt;(</p>
                                        <p>&amp;Value</p>
                                        <p>.Size),</p>
                                        <p>           sizeof(Value.Size) + Value.Size * sizeof(Value.Elements[0])));</p>
                                        <p>     } else {</p>
                                        <p>       // `addRange` will take care of encoding the size.</p>
                                        <p>       HBuilder.addRange(</p>
                                        <p>&amp;Value</p>
                                        <p>.Elements[0], </p>
                                        <p>&amp;Value</p>
                                        <p>.Elements[0] +</p>
                                        <p>       Value.Size);</p>
                                        <p>     }</p>
                                        <p>   }</p>
                                        <p> };</p>
                                        <p> ```</p>
                                    </div>
                                </div>
                                <p>Defined at line 292 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2C1A825BB0F9B0B4A5033FF998D3EE29FFC2C74E">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T1, typename T2&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">HashBuilder&lt;HasherT, Endianness&gt; &amp; add (const std::pair&lt;T1, T2&gt; &amp; Value)</code></pre>
                                <p>Defined at line 301 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8504AF96D5DD7DAA8770DA85989939FAC2BFA77E">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename... Ts&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">HashBuilder&lt;HasherT, Endianness&gt; &amp; add (const std::tuple&lt;Ts...&gt; &amp; Arg)</code></pre>
                                <p>Defined at line 305 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="02B525FB4F28AD7CC195FA3EFB4A0EC6E3FD7BEB">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename... Ts&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">std::enable_if_t&lt;(sizeof...(Ts) &gt; 1), HashBuilder&lt;HasherT, Endianness&gt; &amp;&gt; add (const Ts &amp;... Args)</code></pre>
                                <div>
                                    <div>
                                        <p> A convenenience variadic helper.</p>
                                        <p> It simply iterates over its arguments, in order.</p>
                                        <p> ```</p>
                                        <p> add(Arg1, Arg2);</p>
                                        <p> ```</p>
                                        <p> is equivalent to</p>
                                        <p> ```</p>
                                        <p> add(Arg1)</p>
                                        <p> add(Arg2)</p>
                                        <p> ```</p>
                                    </div>
                                </div>
                                <p>Defined at line 321 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5E2C66F7D9C4ADB0E01BE22EECB7334DFB6D5EA5">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename... Ts&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">int add (const Ts &amp;... Args)</code></pre>
                                <div>
                                    <div>
                                        <p> A convenenience variadic helper.</p>
                                        <p> It simply iterates over its arguments, in order.</p>
                                        <p> ```</p>
                                        <p> add(Arg1, Arg2);</p>
                                        <p> ```</p>
                                        <p> is equivalent to</p>
                                        <p> ```</p>
                                        <p> add(Arg1)</p>
                                        <p> add(Arg2)</p>
                                        <p> ```</p>
                                    </div>
                                </div>
                                <p>Defined at line 321 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6DE11CD07169F35585B89204213C286098CD1626">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename ForwardIteratorT&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">HashBuilder&lt;HasherT, Endianness&gt; &amp; addRange (ForwardIteratorT First, ForwardIteratorT Last)</code></pre>
                                <p>Defined at line 326 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="7C8C407D05884AE7385331B3B9E3AF2A55AE4E0D">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename RangeT&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">HashBuilder&lt;HasherT, Endianness&gt; &amp; addRange (const RangeT &amp; Range)</code></pre>
                                <p>Defined at line 331 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="25C40B3FB754C32F8937656046917DD8C954BE3A">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename ForwardIteratorT&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">HashBuilder&lt;HasherT, Endianness&gt; &amp; addRangeElements (ForwardIteratorT First, ForwardIteratorT Last)</code></pre>
                                <p>Defined at line 336 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="69620D7A77455BD723D3DB37CF5F2E82F6BFD5DD">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename RangeT&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">HashBuilder&lt;HasherT, Endianness&gt; &amp; addRangeElements (const RangeT &amp; Range)</code></pre>
                                <p>Defined at line 343 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="A4B02CD61247479AF11882773B339B4FF6D5B835">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">std::enable_if_t&lt;is_detected&lt;HasByteSwapT, T&gt;::value, HashBuilder&lt;HasherT, Endianness&gt; &amp;&gt; adjustForEndiannessAndAdd (const T &amp; Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Adjust `Value` for the target endianness and add it to the hash.</p>
                                    </div>
                                </div>
                                <p>Defined at line 352 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1D57F5E81E00E96C94EFDBDF5D74E67C6EAFAE25">
                                <pre><code class="language-cpp code-clang-doc">template &lt;typename T&gt;</code></pre>
                                <pre><code class="language-cpp code-clang-doc">int adjustForEndiannessAndAdd (const T &amp; Value)</code></pre>
                                <div>
                                    <div>
                                        <p> Adjust `Value` for the target endianness and add it to the hash.</p>
                                    </div>
                                </div>
                                <p>Defined at line 352 of file llvm/include/llvm/Support/HashBuilder.h</p>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </main>
</body>
</html>

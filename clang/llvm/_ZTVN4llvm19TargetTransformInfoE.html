<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8"/>
    <title>TargetTransformInfo</title>
        <link rel="stylesheet" type="text/css" href="../clang-doc-mustache.css"/>
        <script src="../mustache-index.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="navbar__container">
            <div class="navbar__logo">
                
            </div>
            <div class="navbar__menu">
                <ul class="navbar__links">
                    <li class="navbar__item">
                        <a href="../index.html" class="navbar__link">Home</a>
                    </li>
                </ul>
            </div>
            <div class="navbar-breadcrumb-container">
                <div class="navbar-breadcrumb-item"><a href="../GlobalNamespace/index.html">Global Namespace</a></div>&rarr;
                <div class="navbar-breadcrumb-item"><a href="./index.html">llvm</a></div>
            </div>
        </div>
    </nav>
    <main>
        <div class="container">
            <div class="sidebar">
                <h2>class TargetTransformInfo</h2>
                <ul>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#PublicMethods">Public Method</a>
                    </li>
                    <li>
                        <ul>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#C88A3AB5A9869B53C373DBA481EA0F7CBAC00AE0">TargetTransformInfo</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#B3A99F152622AA28AC4B9B447261CB48FF02C17E">TargetTransformInfo</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#AB69F9575FB777C813884D84AFBF62411D1EC082">operator=</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#B7958F2C1D035EE2425B9E3A293A59BFB5393682">~TargetTransformInfo</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#65C6A3D23BD085A785847CF263598D2D3E1B9D88">invalidate</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#65B65E7169BE129FD9079D55A70FC662710FB94F">invalidate</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F79C0B9DD194D4E53F2A77C2F2A2857E0F130A4F">getInstructionCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6C922688F038B5C86F25B76618152958F10F029D">getPartialReductionExtendKind</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#CDCC47A6C8C42E7DCFC8001DBC5C639660B0ED5A">getPartialReductionExtendKind</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F64ACA4AEA676C214A05F17EF76742B021903742">TargetTransformInfo</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F8B750EB7AF8B3FECD811C0AEFFE7E69D587973E">TargetTransformInfo</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#DB3BD4F810B616524C38874DAEFB432EDCF09350">getGEPCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0D65DE84E428A8D972B1EC94829F92F695F8F008">getPointersChainCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#04FE052E3B1028638A13D5AA30837BEAF9C103DF">getInliningThresholdMultiplier</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1430D7C8D397F1F186DA4E98278A4FD1BFA8F1DE">getInliningCostBenefitAnalysisSavingsMultiplier</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#B15D4286B67C00DEBD6945354750F66A9BDB1514">getInliningCostBenefitAnalysisProfitableMultiplier</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#A06286F482855A9DBCE1971AB13DA1B0B5E955F1">getInliningLastCallToStaticBonus</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6B3DF3FE8982EBCF85C555C9D61B43FDB12A40D9">adjustInliningThreshold</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6BBB60314735F0FC06843389F53CEF6965481718">getCallerAllocaCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#655434316838039A9E4EAF828F3620616FE69BB3">getInlinerVectorBonusPercent</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6B33222D2A49A264614AF34BAC431A4C453A18DD">getMemcpyCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F24C59AA5B38C0E4B5435D529F552FC406104D20">getMaxMemIntrinsicInlineSizeThreshold</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#C6C61675536AC3A015B3795E0F6D8578B0DD15F8">getEstimatedNumberOfCaseClusters</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E2F0BAAFEC1267F38DA46BFD549FD29B92E7563E">getInstructionCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#3AC754C4B11AFD8E7F39CCC4E1A5D94BC65A1591">getPredictableBranchThreshold</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2A893E161906F2763995DF5017AEDEE15E9E69DA">getBranchMispredictPenalty</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#093CBE77BA66FCD62047F6FF582DF2AECB95B414">hasBranchDivergence</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2C17630AAFE519F95521BFF56A72D45D42A44CD3">getInstructionUniformity</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#02BF9057D949202F6E62602CA97BD30A6C946A60">isValidAddrSpaceCast</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#FA235FE24B845C31900922EC3747FCF2E9902810">addrspacesMayAlias</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#33996ED0A712F7DC0D40C8A7FFB2E5C41B646F0F">getFlatAddressSpace</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#CD462A2F7539DC30DB43FA71E334986400DE5779">collectFlatAddressOperands</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#FDA6F942644C5DC7E0471CF9B33C3E31C42D3638">isNoopAddrSpaceCast</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1359749E9E192F832C644D0EE51A1D430DF6A3FE">canHaveNonUndefGlobalInitializerInAddressSpace</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2B3D086B7092082A7B2A3627B1CB18A188E78D56">getAssumedAddrSpace</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#31F2F9FD5D302E1871CA5779642D756F55CBB095">isSingleThreaded</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#91A172418DDDDD5AB6CD8A729329A06DBB7CC9C6">getPredicatedAddrSpace</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#3946D6E9A07F4BB2350205F5D1DEDDDB0C51687A">rewriteIntrinsicWithAddressSpace</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#D6864AAC3F10B498751BF12313190999FE8F131F">isLoweredToCall</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F87250A2E45039A78986D51C44E26A104A799615">getUnrollingPreferences</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#800E6B299BF5B706E0730AE9C6E086470F99CA72">isHardwareLoopProfitable</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#583EBC02EC8E7621EC2A70F30677C8AFE5FF01F4">getEpilogueVectorizationMinVF</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#BD43E405B450A6A658C409B6EDC0BDB17EBEA909">preferPredicateOverEpilogue</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#EFEA128D1661304D4F026A6F8D31FEB5CC91FEFB">getPreferredTailFoldingStyle</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1A5B6260242A4940414E3C52EE49B3779D9241A0">getPeelingPreferences</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E1E4275F00372C544D11FB9BE053FDEDBF254D6F">instCombineIntrinsic</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#98AA4180922500451ABC03C938DEAFA3AFF0731C">simplifyDemandedUseBitsIntrinsic</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#4F0E017043A2FC73FFC85F5C4D9E0BCFC1B0DBE4">simplifyDemandedVectorEltsIntrinsic</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0654A614522B63B7394BDB6482CD36260B65B4C8">isLegalAddImmediate</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#01A36ECDD928E63C1FEE7BFF645DE8570611F1A7">isLegalAddScalableImmediate</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6950CEAE6E0DC126F4050D1B99FDB6782FCA7693">isLegalICmpImmediate</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#19D99DB44F36AA98437AD5A8B63AE401C87158EE">isLegalAddressingMode</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#3D1448391ED117F8550CDF76DBC04E27BA586342">isLSRCostLess</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#17CEE7F55A243F08B15C43B34DE451FA570D070B">isNumRegsMajorCostOfLSR</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#EC1A3B5A300B028F5D894F5989FC126BCDE7A95D">shouldDropLSRSolutionIfLessProfitable</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#959EE991917921C618FB82F1C4D747E460429FE6">isProfitableLSRChainElement</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#DA1B40AA57B31BD896B31474C63776097C67E209">canMacroFuseCmp</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#4B91DCD4C207096A52E08CB9A5A99CF137AD3B77">canSaveCmp</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8DD921C81E6C45A15B5B198DB84BC273121D7C95">getPreferredAddressingMode</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#80EF1BE1CAD69ED430583D363A6FE28DDE29CC81">isLegalMaskedStore</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0C67147F5223CB3AE370E7793034EB43A33B338F">isLegalMaskedLoad</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#B99A7F7235D8A0F0FA8864B797F7C22D38C8BA1B">isLegalNTStore</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2A4FB81FD2364AC9602504EAFC2FC38955D3FC2D">isLegalNTLoad</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#B6AA1360FF8632672A84DFDDE6CDD00AED94209F">isLegalBroadcastLoad</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E523E0CB65E4A106151AE81192602F64E31383E2">isLegalMaskedScatter</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#A8E8B9B05BCC90B67507F1105A0A5EACBAF23EF6">isLegalMaskedGather</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1D459293329806F779047C697ACB77BA2047EB79">forceScalarizeMaskedGather</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#65743EA3B0101B69EE14FABE326EB1E64D49E1F3">forceScalarizeMaskedScatter</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#08E4ADE71EA4F501FB7C5CA077D52F234023E809">isLegalMaskedCompressStore</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#822EEEDC63C4E51120815F55B802B0C16FA3209B">isLegalMaskedExpandLoad</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F2D4F4EAF8731414D6A5CCAC197F08790FCE3A80">isLegalStridedLoadStore</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#A6596ABAF8C7C23C0B33F9601FB71BAA6E4F5433">isLegalInterleavedAccessType</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#9840B28C32620297DB5FB1F470050551A0A4FCE2">isLegalMaskedVectorHistogram</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5270D569E4C98F81AC0607199319A66D6A6DCDAE">isLegalAltInstr</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0FAE6450FA400B7ACE8BFB57848A1C015982DE1E">enableOrderedReductions</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1509C06674F2D23AF842043CF4CD7F39262A6BD8">hasDivRemOp</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#470632B01532833B2B9F68D9DEF6433B19A5AD4F">hasVolatileVariant</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6ADB716E1DBAE09581DE0C7200F14FBC2425267E">prefersVectorizedAddressing</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5B52611FEEB82C748DE331A88BBA55AE231AC35C">getScalingFactorCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6B3A3BE5152A6CA6E551B67E2404F62ABA3CA225">LSRWithInstrQueries</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#D2660BF64050480B9E18FB04CC2B2DFAEA0196C6">isTruncateFree</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#66CE702F886C1A3A0DF1611842368C87D10D22E3">isProfitableToHoist</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#25F28670075C18AE9A6C6C197EC0273D0ABBE1E9">useAA</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#59A7D324CF57E12B9A1656609B3D6761C556F554">isTypeLegal</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#ACB5FAAD486D7EEADF5435D3E76945D0BCD22FE4">getRegUsageForType</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#FC9C9AB1607B3C38354B8AC10B79A9896AD6532A">shouldBuildLookupTables</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#7737D117EC575AF463350904BDB06C010AD40945">shouldBuildLookupTablesForConstant</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#14DEBAEDC876122B6EE939FD709BA4721348D2D9">shouldBuildRelLookupTables</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#3DA4859DFBC7979084FA1A6ED2038D42879B2CA4">useColdCCForColdCall</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#68C5BD87A045B4F3D347439D84B79544F2C3E630">useFastCCForInternalCall</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#DA222EA2C5042F322FE52E365A10E5D7966D49A0">isTargetIntrinsicTriviallyScalarizable</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E85599A95B3298DC50465350E95FD1EF745C0E26">isTargetIntrinsicWithScalarOpAtArg</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#18D76602BEC9F4E85BCF3F19B19C43B218E79EE1">isTargetIntrinsicWithOverloadTypeAtArg</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2D69EBCDB270C7B9F79A52D9DA055AAF3BAAC06A">isTargetIntrinsicWithStructReturnOverloadAtField</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#C04B1BA493A8F9D3B3EC51117EFC061FB3C50D17">getScalarizationOverhead</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#71279EA7F79A02F876B12A554856BC87F8CA02C6">getOperandsScalarizationOverhead</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#4BF608B70FA54DA10CA1E935DE0C548F6725ABEB">supportsEfficientVectorElementLoadStore</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#BE866D59D6BE783A49523FF47FC1E405890876D6">supportsTailCalls</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6871B12279D9C1CD335E1679E92FC45C1F3BDFE4">supportsTailCallFor</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1C13CD1DA4E9952487A8785E5BB6E9CA76E383D5">enableAggressiveInterleaving</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#B2CAD04698A2DE20606FE59F9E0C80D0E1733E7F">enableMemCmpExpansion</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#96A7C8BE9AC807CDCA128EE81BE5373A22E1F83C">enableSelectOptimize</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#9DD5D720DDF1172C8135208B539A2F4AB57050FD">shouldTreatInstructionLikeSelect</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E50E8FB5153F0C35E5B431C31ACE02492189CF17">enableInterleavedAccessVectorization</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#A3D3FFDAB5544AA3777DAAFE92F11B09DBC63EB0">enableMaskedInterleavedAccessVectorization</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#99BF237FA602D88FF2B1A25991370D8722553BEB">isFPVectorizationPotentiallyUnsafe</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#045458F8E1A0C3C7E295108A9524ECC89D7C4CCD">allowsMisalignedMemoryAccesses</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#7BB76D9C68CEC85830663E197B54E446305B1F6A">getPopcntSupport</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#7BE509CC0102BDF250056DB1B9F2AD54447C5CC6">haveFastSqrt</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2F26C9BD0B4A683BC2C1E6F593D922D56AF8656C">isExpensiveToSpeculativelyExecute</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5779780134073ABEC90FD5570D13481409A624DA">isFCmpOrdCheaperThanFCmpZero</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#54C1642AA7DAF1E6478CC938843186E611529206">getFPOpCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0904112798377032024705753C79DD6B9949BFE2">getIntImmCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#C45881E0853AC7039C7EBF115755B3CD1CBF234D">getIntImmCostInst</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#468983B937EE5DBAC3943F0928CCF6995A841B40">getIntImmCostIntrin</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#ADCECDFE4075E78576975C6B657EF71CF6FD3151">getIntImmCodeSizeCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#175A5EB7656868CE765124A76E648308AF07C9E5">preferToKeepConstantsAttached</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8B89174B1442F6CB687E4E21A1A96F1046777BF0">getNumberOfRegisters</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#3DD1FCAEC2FA3D8A24CE4A88AA58DBDF4C41A1BD">hasConditionalLoadStoreForType</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5F28032E8382173C98C13C386D8FE3EC18AD6E05">getRegisterClassForType</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2719AEE9D307EB2BA34891984945E3D90225CB3D">getRegisterClassName</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E0B0CCA79ED22273A0B9525AA577A1E1A5D134E8">getRegisterBitWidth</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1459280368AA397002107042D474ED0C88D44785">getMinVectorRegisterBitWidth</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#BAB6BEDB5E7AC78E2008FA81BB4667E4D5D70757">getMaxVScale</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#783735AD87EFD07E35B21FCFE6F28430265A2E3E">getVScaleForTuning</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#66599CA57AAE964308F9C22C5D45881D7ECF7EAB">isVScaleKnownToBeAPowerOfTwo</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#AA62F2CA2A713144177ABE6E79B0F251C8512410">shouldMaximizeVectorBandwidth</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#87C5D3BFB0EBB741EAD376D735A9DDA0795E0104">getMinimumVF</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#93B15180881925FC1D4ED3718D203F46922EE0D1">getMaximumVF</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#A1E141BD19344E1440D103813EE0717B00745821">getStoreMinimumVF</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#AAAF4C1EA3B4354310504000D80FA599F56AA827">shouldConsiderAddressTypePromotion</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#9FEEAC82B37D172FB01A7D9DD1AA5CF23018B3F8">getCacheLineSize</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#3D818AD87874406079A82EE7ED4DA9F4729DBE62">getCacheSize</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#AA1B6D960B2D9CAE2DCE57F737C75C7B5C1F88AA">getCacheAssociativity</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F78F750E9EC321080A460710DAD4D22C476C0F61">getMinPageSize</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2122C900E508F924205AD704619684B23AFF621A">getPrefetchDistance</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#72721B1D5B395CC6326F707115F338392FC4ED87">getMinPrefetchStride</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#EC0ACABF5812853617EF709E1B1311EEF204035D">getMaxPrefetchIterationsAhead</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#D69432CACC95100E046C9028179BC898A8DBA3B1">enableWritePrefetching</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#17BC2244BB969E8211DAFEC787BB7A3CBBCA85D2">shouldPrefetchAddressSpace</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#DC167F816FEC24447B187EFF0AADCC0D10C52329">getPartialReductionCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#25986C0784E67827FAECB8BB62BAA5F50ABC4624">getMaxInterleaveFactor</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F7FA40FF21BCCE1655F5F8C6462660E4C67E8113">getOperandInfo</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#FF1281FCBB438E2F2D6FB0EEA0CA196358368F62">getArithmeticInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#68B0482974D178C91F826B2DD2BB23158E23DDE5">getAltInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F143F2486E33C21ED2B6FDADB46EC3A047D13235">getShuffleCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2172E5A529F2DEF92DBF6BAEFB9CD91BBD377347">getCastContextHint</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#EABE93253F4F9EC7782DF1931091CFD53D381781">getCastInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F9783F6265F63F778B92CC798B27CE83325C849B">getExtractWithExtendCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#409D2CF5BC565D3D4F59FEEA768A9B2B958E3138">getCFInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#693C3F52D4E57E0144FA0CF90DD3A51BAFC4C91C">getCmpSelInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#24C61247DBD4891A7D708284617440DA36BBE1C1">getVectorInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#DE132AB4C8C2BDDE85E9A329504439633D1869E0">getVectorInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#391080C6B59CDEA9C894E906CC62F598898FAEB3">getVectorInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#DF683F9E7F9E7FF68206358C04ACF1F96B7B6EF4">getIndexedVectorInstrCostFromEnd</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8615DB92CB69E51EA35FB5227FCED66AB449956A">getInsertExtractValueCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#21ADC7A8DE92474632BAEA0FD2998FD895A5771A">getReplicationShuffleCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#903670645B399E9DF1B68B9669617A60C7FBAA0A">getMemoryOpCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0C14B57A6DDD4FFB23E28B4327699E0DE9387AB3">getInterleavedMemoryOpCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E2FD7BD5807BC22209DBBD94CFFCECDDF20938F6">getArithmeticReductionCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#03FF1B644009274D0F465E3A08F018713825A2A9">getMinMaxReductionCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#C518E0FCA0FC11811DAC13B88379F794BE852015">getMulAccReductionCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#08E7AE2DCF83AB6ABB1A40E9AE17891DD9F7FB25">getExtendedReductionCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8FAD10B1D8E832206F1CC01256C6C60ADF794725">getIntrinsicInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F287390D9ACE5442076B24DA46D6C7B0726C3A04">getMemIntrinsicInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#658DB07807CDE2D30792594B6B432273FD87C326">getCallInstrCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#FD56C7D3B0CE350FE2EA92973D33E3EAE3D8028C">getNumberOfParts</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#D01721A374D169E36E670AE0AB385B4FF4B99CAC">getAddressComputationCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#9BFB22324BE3494F47BE30AB6042DD912D2C64BC">getCostOfKeepingLiveOverCall</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5E46BAE8455B464DF65788BAE737E94AD2C5C3F5">getTgtMemIntrinsic</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E4224B4C01ACE7973C7A3129B14532C18CE60C10">getAtomicMemIntrinsicMaxElementSize</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#ADDD4AFC69D1CEB2D54C41680AEFC6B194B41AC6">getOrCreateResultFromMemIntrinsic</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#94FC009BD541DEB6CCB2163F255F12FE07437C49">getMemcpyLoopLoweringType</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#DD71F483F2A72C34B30157F9804111E9E150E939">getMemcpyLoopResidualLoweringType</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#704617D6EE74316D86F3AB222FD5BFF2AA6C98E4">areInlineCompatible</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2665D13986D3A9B09121D1BE2D4D3C25085A264B">getInlineCallPenalty</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#AFCE8B492666E055081058580E7A646C83491ACE">areTypesABICompatible</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#A3B3A8FA027BB25A24C812343EDACEF7F5698799">isIndexedLoadLegal</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8F0A641F9A319454B0DC2F21AF81AFF6DF8F2B14">isIndexedStoreLegal</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6E951F4C6F456BCA9326B1192DEABD434832A418">getLoadStoreVecRegBitWidth</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#9B6E99CA89AEF21B073DF25AC1ED0640ADC478B8">isLegalToVectorizeLoad</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#BDA308B11F7AB40E0C2A7066555237010FA439B9">isLegalToVectorizeStore</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2C9B075C3C8C66AC8ADA91A17791F63183F9435A">isLegalToVectorizeLoadChain</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#7F96DC2A5DC76356436E32CD1FE4C75DC9BE0F99">isLegalToVectorizeStoreChain</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#EA19F3F58026227E89961F301B797C032B950EA6">isLegalToVectorizeReduction</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5EE65F4DC8F45FB8509082CDB4F79FFE33B3B129">isElementTypeLegalForScalableVector</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1FC5AC54470A818945DFB36FD6B979EC7EAE6523">getLoadVectorFactor</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#064D8917CA118FF46903E8D05A4A55547F0CB6E4">getStoreVectorFactor</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#E8FF2DCE11CCDD93B495AAB80FF4D5D6A5979D96">preferFixedOverScalableIfEqualCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8FDC546DA05FFB77BC78F1ECFB4A13E121DDA019">preferAlternateOpcodeVectorization</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#263EEAAB8482A7EEAC082C9783E3CC8DB1BB0060">preferInLoopReduction</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#9380F5E5195E0601172504E608847804FA911E19">preferPredicatedReductionSelect</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#6BBFD6D88D282ACC1E10D7FCB37A43202F0AC2EA">preferEpilogueVectorization</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#AD56A2032ED723728C53FB8D78EA9BE220AEC923">shouldConsiderVectorizationRegPressure</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#527B858A4ECD93E0F3D8500E7D79791C974D1E3D">shouldExpandReduction</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#4BAC0D8658471BA901424693461C22CAEB0D46C4">getPreferredExpandedReductionShuffle</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#2999B6BA2194D98ED1B87A0B561F24F3B71980A0">getGISelRematGlobalCost</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#7147B4A94F8A66FAA7A884AAA96E3C40532D52C8">getMinTripCountTailFoldingThreshold</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8FDCA26DCF30EFF51EB495CA159EE75771D3256A">supportsScalableVectors</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#FBBD3B4C4A0A4774C9392A943ADA467961F0AA4B">enableScalableVectorization</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#CC3476656024B34576DE7F53729894F6B850C270">hasActiveVectorLength</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#1E0206FE465EFA5775DCE6906C134BC68986D4FC">isProfitableToSinkOperands</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F806C2B48BF02E8A6035ED97BAC3CDE85C46B371">isVectorShiftByScalarCheap</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#F8F19A504552B9C02269253B383C508AC45D47D7">getVPLegalizationStrategy</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#66DB612FF20C861EC5331FE69C5F5015D5650E32">hasArmWideBranch</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#D34677A261AB9B885304EA45B1E04DF1DA78DD2F">getFeatureMask</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#8A8C31C78C2D4D930ECA19CE9CE12F0DC3154424">getPriorityMask</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#58A8415E1FA8BB146161AEEC9B233D6B818D6D08">isMultiversionedFunction</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#5359608573B28FE801D8730C2D99933307D1CF8A">getMaxNumArgs</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0EE88686E02E5AD75D6B0F3F14C31D61FE55CE05">getNumBytesToPadGlobalArray</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#CFAB00E090E5DA7780BE0C0E6EEB54EA281B00B3">collectKernelLaunchBounds</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#AA79A686107FB6DC2EFAB082CB2EEA846E57C2F8">allowVectorElementIndexingUsingGEP</a>
                            </li>
                            <li class="sidebar-item-container">
                                <a class="sidebar-item" href="#0205C61D21F889FCF09E710BAD514EEC43C9114A">requiresOrderedReduction</a>
                            </li>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                    <li class="sidebar-section">
                        <a class="sidebar-item" href="#Enums">Enums</a>
                    </li>
                    <li>
                        <ul>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="resizer" id="resizer"></div>
            <div class="content">
                <section class="hero section-container">
                    <div class="hero__title">
                        <h1 class="hero__title-large">class TargetTransformInfo</h1>
                        <p>Defined at line 278 of file llvm/include/llvm/Analysis/TargetTransformInfo.h</p>
                        <div class="hero__subtitle">
                            <div>
                                <p> This pass provides access to the codegen interfaces that are needed</p>
                                <p> for IR-level transformations.</p>
                            </div>
                        </div>
                    </div>
                </section>
                <section id="PublicMethods" class="section-container">
                    <h2>Public Methods</h2>
                    <div>
                        <div class="delimiter-container">
                            <div id="C88A3AB5A9869B53C373DBA481EA0F7CBAC00AE0">
                                <pre><code class="language-cpp code-clang-doc">void TargetTransformInfo (unique_ptr Impl)</code></pre>
                                <div>
                                    <div>
                                        <p> Construct a TTI object using a type implementing the </p>
                                        <p> API below.</p>
                                    </div>
                                    <div>
                                        <p> This is used by targets to construct a TTI wrapping their target-specific</p>
                                        <p> implementation that encodes appropriate costs for their target.</p>
                                    </div>
                                </div>
                                <p>Defined at line  of file </p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="B3A99F152622AA28AC4B9B447261CB48FF02C17E">
                                <pre><code class="language-cpp code-clang-doc">void TargetTransformInfo (TargetTransformInfo &amp;&amp; Arg)</code></pre>
                                <div>
                                    <div>
                                        <p> Provide move semantics.</p>
                                    </div>
                                </div>
                                <p>Defined at line 211 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="AB69F9575FB777C813884D84AFBF62411D1EC082">
                                <pre><code class="language-cpp code-clang-doc">TargetTransformInfo &amp; operator= (TargetTransformInfo &amp;&amp; RHS)</code></pre>
                                <p>Defined at line 214 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="B7958F2C1D035EE2425B9E3A293A59BFB5393682">
                                <pre><code class="language-cpp code-clang-doc">void ~TargetTransformInfo ()</code></pre>
                                <div>
                                    <div>
                                        <p> We need to define the destructor out-of-line to define our sub-classes</p>
                                        <p> out-of-line.</p>
                                    </div>
                                </div>
                                <p>Defined at line 209 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="65C6A3D23BD085A785847CF263598D2D3E1B9D88">
                                <pre><code class="language-cpp code-clang-doc">bool invalidate (Function &amp; , const PreservedAnalyses &amp; , int &amp; )</code></pre>
                                <div>
                                    <div>
                                        <p> Handle the invalidation of this information.</p>
                                    </div>
                                    <div>
                                        <p> When used as a result of </p>
                                        <p> this method will be called</p>
                                        <p> when the function this was computed for changes. When it returns false,</p>
                                        <p> the information is preserved across those changes.</p>
                                    </div>
                                </div>
                                <p>Defined at line 317 of file llvm/include/llvm/Analysis/TargetTransformInfo.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="65B65E7169BE129FD9079D55A70FC662710FB94F">
                                <pre><code class="language-cpp code-clang-doc">bool invalidate (Function &amp; , const PreservedAnalyses &amp; , FunctionAnalysisManager::Invalidator &amp; )</code></pre>
                                <div>
                                    <div>
                                        <p> Handle the invalidation of this information.</p>
                                    </div>
                                    <div>
                                        <p> When used as a result of </p>
                                        <p> this method will be called</p>
                                        <p> when the function this was computed for changes. When it returns false,</p>
                                        <p> the information is preserved across those changes.</p>
                                    </div>
                                </div>
                                <p>Defined at line 317 of file llvm/include/llvm/Analysis/TargetTransformInfo.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F79C0B9DD194D4E53F2A77C2F2A2857E0F130A4F">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getInstructionCost (const User * U, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> This is a helper function which calls the three-argument</p>
                                        <p> getInstructionCost with </p>
                                        <p> which are the current operands U has.</p>
                                    </div>
                                </div>
                                <p>Defined at line 488 of file llvm/include/llvm/Analysis/TargetTransformInfo.h</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6C922688F038B5C86F25B76618152958F10F029D">
                                <pre><code class="language-cpp code-clang-doc">PartialReductionExtendKind getPartialReductionExtendKind (Instruction * I)</code></pre>
                                <div>
                                    <div>
                                        <p> Get the kind of extension that an instruction represents.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1008 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="CDCC47A6C8C42E7DCFC8001DBC5C639660B0ED5A">
                                <pre><code class="language-cpp code-clang-doc">PartialReductionExtendKind getPartialReductionExtendKind (CastOps CastOpc)</code></pre>
                                <div>
                                    <div>
                                        <p> Get the kind of extension that a cast opcode represents.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1015 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F64ACA4AEA676C214A05F17EF76742B021903742">
                                <pre><code class="language-cpp code-clang-doc">void TargetTransformInfo (int Impl)</code></pre>
                                <div>
                                    <div>
                                        <p> Construct a TTI object using a type implementing the </p>
                                        <p> API below.</p>
                                    </div>
                                    <div>
                                        <p> This is used by targets to construct a TTI wrapping their target-specific</p>
                                        <p> implementation that encodes appropriate costs for their target.</p>
                                    </div>
                                </div>
                                <p>Defined at line 61 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F8B750EB7AF8B3FECD811C0AEFFE7E69D587973E">
                                <pre><code class="language-cpp code-clang-doc">void TargetTransformInfo (const DataLayout &amp; DL)</code></pre>
                                <div>
                                    <div>
                                        <p> Construct a baseline TTI object using a minimal implementation of</p>
                                        <p> the </p>
                                        <p> API below.</p>
                                    </div>
                                    <div>
                                        <p> The TTI implementation will reflect the information in the DataLayout</p>
                                        <p> provided if non-null.</p>
                                    </div>
                                </div>
                                <p>Defined at line 206 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="DB3BD4F810B616524C38874DAEFB432EDCF09350">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getGEPCost (Type * PointeeType, const Value * Ptr, ArrayRef Operands, Type * AccessType, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Estimate the cost of a GEP operation when lowered.</p>
                                    </div>
                                    <div>
                                        <p> is the source element type of the GEP.</p>
                                        <p> is the base pointer operand.</p>
                                        <p> is the list of indices following the base pointer.</p>
                                    </div>
                                    <div>
                                        <p> is a hint as to what type of memory might be accessed by</p>
                                        <p> users of the GEP. getGEPCost will use it to determine if the GEP can be</p>
                                        <p> folded into the addressing mode of a load/store. If AccessType is null,</p>
                                        <p> then the resulting target type based off of PointeeType will be used as an</p>
                                        <p> approximation.</p>
                                    </div>
                                </div>
                                <p>Defined at line 252 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0D65DE84E428A8D972B1EC94829F92F695F8F008">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getPointersChainCost (ArrayRef Ptrs, const Value * Base, const PointersChainInfo &amp; Info, Type * AccessTy, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Estimate the cost of a chain of pointers (typically pointer operands of a</p>
                                        <p> chain of loads or stores within same block) operations set when lowered.</p>
                                        <p> is the type of the loads/stores that will ultimately use the</p>
                                    </div>
                                </div>
                                <p>Defined at line 258 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="04FE052E3B1028638A13D5AA30837BEAF9C103DF">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getInliningThresholdMultiplier ()</code></pre>
                                <div>
                                    <div>
                                        <p> TODO: This is a rather blunt instrument.  Perhaps altering the costs of</p>
                                        <p> individual classes of instructions would be better.</p>
                                    </div>
                                </div>
                                <p>Defined at line 219 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1430D7C8D397F1F186DA4E98278A4FD1BFA8F1DE">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getInliningCostBenefitAnalysisSavingsMultiplier ()</code></pre>
                                <p>Defined at line 223 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="B15D4286B67C00DEBD6945354750F66A9BDB1514">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getInliningCostBenefitAnalysisProfitableMultiplier ()</code></pre>
                                <p>Defined at line 228 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="A06286F482855A9DBCE1971AB13DA1B0B5E955F1">
                                <pre><code class="language-cpp code-clang-doc">int getInliningLastCallToStaticBonus ()</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 234 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6B3DF3FE8982EBCF85C555C9D61B43FDB12A40D9">
                                <pre><code class="language-cpp code-clang-doc">unsigned int adjustInliningThreshold (const CallBase * CB)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 238 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6BBB60314735F0FC06843389F53CEF6965481718">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getCallerAllocaCost (const CallBase * CB, const AllocaInst * AI)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 243 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="655434316838039A9E4EAF828F3620616FE69BB3">
                                <pre><code class="language-cpp code-clang-doc">int getInlinerVectorBonusPercent ()</code></pre>
                                <div>
                                    <div>
                                        <p> Vector bonuses: We want to more aggressively inline vector-dense kernels</p>
                                        <p> and apply this bonus based on the percentage of vector instructions. A</p>
                                        <p> bonus is applied if the vector instructions exceed 50% and half that</p>
                                        <p> amount is applied if it exceeds 10%. Note that these bonuses are some what</p>
                                        <p> arbitrary and evolved over time by accident as much as because they are</p>
                                        <p> principled bonuses.</p>
                                        <p> FIXME: It would be nice to base the bonus values on something more</p>
                                        <p> scientific. A target may has no bonus on vector instructions.</p>
                                    </div>
                                </div>
                                <p>Defined at line 248 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6B33222D2A49A264614AF34BAC431A4C453A18DD">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getMemcpyCost (const Instruction * I)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> the expected cost of a memcpy, which could e.g. depend on the</p>
                                    <p> source/destination type and alignment and the number of bytes copied.</p>
                                </div>
                                <p>Defined at line 1240 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F24C59AA5B38C0E4B5435D529F552FC406104D20">
                                <pre><code class="language-cpp code-clang-doc">uint64_t getMaxMemIntrinsicInlineSizeThreshold ()</code></pre>
                                <div>
                                    <div>
                                        <p> Returns the maximum memset / memcpy size in bytes that still makes it</p>
                                        <p> profitable to inline the call.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1246 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="C6C61675536AC3A015B3795E0F6D8578B0DD15F8">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getEstimatedNumberOfCaseClusters (const SwitchInst &amp; SI, unsigned int &amp; JTSize, ProfileSummaryInfo * PSI, BlockFrequencyInfo * BFI)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The estimated number of case clusters when lowering </p>
                                    <p> Set a jump table size only when </p>
                                    <p> is suitable for a jump</p>
                                    <p> table.</p>
                                </div>
                                <p>Defined at line 267 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E2F0BAAFEC1267F38DA46BFD549FD29B92E7563E">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getInstructionCost (const User * U, ArrayRef Operands, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Estimate the cost of a given IR user when lowered.</p>
                                    </div>
                                    <div>
                                        <p> This can estimate the cost of either a ConstantExpr or Instruction when</p>
                                        <p> lowered.</p>
                                    </div>
                                    <div>
                                        <p> is a list of operands which can be a result of transformations</p>
                                        <p> of the current operands. The number of the operands on the list must equal</p>
                                        <p> to the number of the current operands the IR user has. Their order on the</p>
                                        <p> list must be the same as the order of the current operands the IR user</p>
                                        <p> has.</p>
                                    </div>
                                    <div>
                                        <p> The returned cost is defined in terms of </p>
                                        <p> see its</p>
                                        <p> comments for a detailed explanation of the cost values.</p>
                                    </div>
                                </div>
                                <p>Defined at line 273 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="3AC754C4B11AFD8E7F39CCC4E1A5D94BC65A1591">
                                <pre><code class="language-cpp code-clang-doc">BranchProbability getPredictableBranchThreshold ()</code></pre>
                                <div>
                                    <div>
                                        <p> If a branch or a select condition is skewed in one direction by more than</p>
                                        <p> this factor, it is very likely to be predicted correctly.</p>
                                    </div>
                                </div>
                                <p>Defined at line 283 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2A893E161906F2763995DF5017AEDEE15E9E69DA">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getBranchMispredictPenalty ()</code></pre>
                                <div>
                                    <div>
                                        <p> Returns estimated penalty of a branch misprediction in latency. Indicates</p>
                                        <p> how aggressive the target wants for eliminating unpredictable branches. A</p>
                                        <p> zero return value means extra optimization applied to them should be</p>
                                        <p> minimal.</p>
                                    </div>
                                </div>
                                <p>Defined at line 289 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="093CBE77BA66FCD62047F6FF582DF2AECB95B414">
                                <pre><code class="language-cpp code-clang-doc">bool hasBranchDivergence (const Function * F)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if branch divergence exists.</p>
                                    </div>
                                    <div>
                                        <p> Branch divergence has a significantly negative impact on GPU performance</p>
                                        <p> when threads in the same wavefront take different paths due to conditional</p>
                                        <p> branches.</p>
                                    </div>
                                    <div>
                                        <p> If </p>
                                        <p> is passed, provides a context function. If </p>
                                        <p> is known to only</p>
                                        <p> execute in a single threaded environment, the target may choose to skip</p>
                                        <p> uniformity analysis and assume all values are uniform.</p>
                                    </div>
                                </div>
                                <p>Defined at line 293 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2C17630AAFE519F95521BFF56A72D45D42A44CD3">
                                <pre><code class="language-cpp code-clang-doc">InstructionUniformity getInstructionUniformity (const Value * V)</code></pre>
                                <div>
                                    <div>
                                        <p> Get target-specific uniformity information for an instruction.</p>
                                        <p> This allows targets to provide more fine-grained control over</p>
                                        <p> uniformity analysis by specifying whether specific instructions</p>
                                        <p> should always or never be considered uniform, or require custom</p>
                                        <p> operand-based analysis.</p>
                                    </div>
                                    <h3>Parameters</h3>
                                    <div>
                                        <b>V</b>   The value to query for uniformity information.
                                    </div> 
                                    <h3>Returns</h3>
                                    <p> InstructionUniformity.</p>
                                </div>
                                <p>Defined at line 297 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="02BF9057D949202F6E62602CA97BD30A6C946A60">
                                <pre><code class="language-cpp code-clang-doc">bool isValidAddrSpaceCast (unsigned int FromAS, unsigned int ToAS)</code></pre>
                                <div>
                                    <div>
                                        <p> Query the target whether the specified address space cast from FromAS to</p>
                                        <p> ToAS is valid.</p>
                                    </div>
                                </div>
                                <p>Defined at line 307 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="FA235FE24B845C31900922EC3747FCF2E9902810">
                                <pre><code class="language-cpp code-clang-doc">bool addrspacesMayAlias (unsigned int AS0, unsigned int AS1)</code></pre>
                                <div>
                                    <div>
                                        <p> Return false if a </p>
                                        <p> address cannot possibly alias a </p>
                                        <p> address.</p>
                                    </div>
                                </div>
                                <p>Defined at line 312 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="33996ED0A712F7DC0D40C8A7FFB2E5C41B646F0F">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getFlatAddressSpace ()</code></pre>
                                <div>
                                    <div>
                                        <p> Returns the address space ID for a target&#39;s &#39;flat&#39; address space. Note</p>
                                        <p> this is not necessarily the same as addrspace(0), which LLVM sometimes</p>
                                        <p> refers to as the generic address space. The flat address space is a</p>
                                        <p> generic address space that can be used access multiple segments of memory</p>
                                        <p> with different address spaces. Access of a memory location through a</p>
                                        <p> pointer with this address space is expected to be legal but slower</p>
                                        <p> compared to the same memory location accessed through a pointer with a</p>
                                        <p> different address space.</p>
                                    </div>
                                    <div>
                                        <p> This is for targets with different pointer representations which can</p>
                                        <p> be converted with the addrspacecast instruction. If a pointer is converted</p>
                                        <p> to this address space, optimizations should attempt to replace the access</p>
                                        <p> with the source address space.</p>
                                    </div>
                                </div>
                                <p>Defined at line 317 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="CD462A2F7539DC30DB43FA71E334986400DE5779">
                                <pre><code class="language-cpp code-clang-doc">bool collectFlatAddressOperands (SmallVectorImpl&lt;int&gt; &amp; OpIndexes, Intrinsic::ID IID)</code></pre>
                                <div>
                                    <div>
                                        <p> Return any intrinsic address operand indexes which may be rewritten if</p>
                                        <p> they use a flat address space pointer.</p>
                                    </div>
                                </div>
                                <p>Defined at line 321 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="FDA6F942644C5DC7E0471CF9B33C3E31C42D3638">
                                <pre><code class="language-cpp code-clang-doc">bool isNoopAddrSpaceCast (unsigned int FromAS, unsigned int ToAS)</code></pre>
                                <p>Defined at line 326 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1359749E9E192F832C644D0EE51A1D430DF6A3FE">
                                <pre><code class="language-cpp code-clang-doc">bool canHaveNonUndefGlobalInitializerInAddressSpace (unsigned int AS)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if globals in this address space can have initializers other</p>
                                        <p> than `undef`.</p>
                                    </div>
                                </div>
                                <p>Defined at line 331 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2B3D086B7092082A7B2A3627B1CB18A188E78D56">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getAssumedAddrSpace (const Value * V)</code></pre>
                                <p>Defined at line 336 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="31F2F9FD5D302E1871CA5779642D756F55CBB095">
                                <pre><code class="language-cpp code-clang-doc">bool isSingleThreaded ()</code></pre>
                                <p>Defined at line 340 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="91A172418DDDDD5AB6CD8A729329A06DBB7CC9C6">
                                <pre><code class="language-cpp code-clang-doc">std::pair&lt;const Value *, unsigned int&gt; getPredicatedAddrSpace (const Value * V)</code></pre>
                                <p>Defined at line 344 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="3946D6E9A07F4BB2350205F5D1DEDDDB0C51687A">
                                <pre><code class="language-cpp code-clang-doc">Value * rewriteIntrinsicWithAddressSpace (IntrinsicInst * II, Value * OldV, Value * NewV)</code></pre>
                                <div>
                                    <div>
                                        <p> Rewrite intrinsic call </p>
                                        <p> such that </p>
                                        <p> will be replaced with </p>
                                        <p> which has a different address space. This should happen for every</p>
                                        <p> operand index that collectFlatAddressOperands returned for the intrinsic.</p>
                                    </div>
                                </div>
                                <p>Defined at line 349 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="D6864AAC3F10B498751BF12313190999FE8F131F">
                                <pre><code class="language-cpp code-clang-doc">bool isLoweredToCall (const Function * F)</code></pre>
                                <div>
                                    <div>
                                        <p> Test whether calls to a function lower to actual program function</p>
                                        <p> calls.</p>
                                    </div>
                                    <div>
                                        <p> The idea is to test whether the program is likely to require a &#39;call&#39;</p>
                                        <p> instruction or equivalent in order to call the given function.</p>
                                    </div>
                                    <div>
                                        <p> FIXME: It&#39;s not clear that this is a good or useful query API. Client&#39;s</p>
                                        <p> should probably move to simpler cost metrics using the above.</p>
                                        <p> Alternatively, we could split the cost interface into distinct code-size</p>
                                        <p> and execution-speed costs. This would allow modelling the core of this</p>
                                        <p> query more accurately as a call is a single small instruction, but</p>
                                        <p> incurs significant execution cost.</p>
                                    </div>
                                </div>
                                <p>Defined at line 354 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F87250A2E45039A78986D51C44E26A104A799615">
                                <pre><code class="language-cpp code-clang-doc">void getUnrollingPreferences (Loop * L, ScalarEvolution &amp; , UnrollingPreferences &amp; UP, OptimizationRemarkEmitter * ORE)</code></pre>
                                <div>
                                    <div>
                                        <p> Get target-customized preferences for the generic loop unrolling</p>
                                        <p> transformation. The caller will initialize UP with the current</p>
                                        <p> target-independent defaults.</p>
                                    </div>
                                </div>
                                <p>Defined at line 401 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="800E6B299BF5B706E0730AE9C6E086470F99CA72">
                                <pre><code class="language-cpp code-clang-doc">bool isHardwareLoopProfitable (Loop * L, ScalarEvolution &amp; SE, AssumptionCache &amp; AC, TargetLibraryInfo * LibInfo, HardwareLoopInfo &amp; HWLoopInfo)</code></pre>
                                <div>
                                    <div>
                                        <p> Query the target whether it would be profitable to convert the given loop</p>
                                        <p> into a hardware loop.</p>
                                    </div>
                                </div>
                                <p>Defined at line 358 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="583EBC02EC8E7621EC2A70F30677C8AFE5FF01F4">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getEpilogueVectorizationMinVF ()</code></pre>
                                <div>
                                    <div>
                                        <p> Query the target for which minimum vectorization factor epilogue</p>
                                        <p> vectorization should be considered.</p>
                                    </div>
                                </div>
                                <p>Defined at line 364 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="BD43E405B450A6A658C409B6EDC0BDB17EBEA909">
                                <pre><code class="language-cpp code-clang-doc">bool preferPredicateOverEpilogue (TailFoldingInfo * TFI)</code></pre>
                                <div>
                                    <div>
                                        <p> Query the target whether it would be prefered to create a predicated</p>
                                        <p> vector loop, which can avoid the need to emit a scalar epilogue loop.</p>
                                    </div>
                                </div>
                                <p>Defined at line 368 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="EFEA128D1661304D4F026A6F8D31FEB5CC91FEFB">
                                <pre><code class="language-cpp code-clang-doc">TailFoldingStyle getPreferredTailFoldingStyle (bool IVUpdateMayOverflow)</code></pre>
                                <div>
                                    <div>
                                        <p> Query the target what the preferred style of tail folding is.</p>
                                    </div>
                                    <h3>Parameters</h3>
                                    <div>
                                        <b>IVUpdateMayOverflow</b>   Tells whether it is known if the IV update may (or will never) overflow for the suggested VF/UF in the given loop. Targets can use this information to select a more optimal tail folding style. The value conservatively defaults to true, such that no assumptions are made on overflow.
                                    </div> 
                                </div>
                                <p>Defined at line 373 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1A5B6260242A4940414E3C52EE49B3779D9241A0">
                                <pre><code class="language-cpp code-clang-doc">void getPeelingPreferences (Loop * L, ScalarEvolution &amp; SE, PeelingPreferences &amp; PP)</code></pre>
                                <div>
                                    <div>
                                        <p> Get target-customized preferences for the generic loop peeling</p>
                                        <p> transformation. The caller will initialize </p>
                                        <p> with the current</p>
                                        <p> target-independent defaults with information from </p>
                                        <p> and </p>
                                    </div>
                                </div>
                                <p>Defined at line 407 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E1E4275F00372C544D11FB9BE053FDEDBF254D6F">
                                <pre><code class="language-cpp code-clang-doc">std::optional&lt;Instruction *&gt; instCombineIntrinsic (InstCombiner &amp; IC, IntrinsicInst &amp; II)</code></pre>
                                <div>
                                    <div>
                                        <p> Targets can implement their own combinations for target-specific</p>
                                        <p> intrinsics. This function will be called from the InstCombine pass every</p>
                                        <p> time a target-specific intrinsic is encountered.</p>
                                    </div>
                                </div>
                                <p>Defined at line 378 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="98AA4180922500451ABC03C938DEAFA3AFF0731C">
                                <pre><code class="language-cpp code-clang-doc">std::optional&lt;Value *&gt; simplifyDemandedUseBitsIntrinsic (InstCombiner &amp; IC, IntrinsicInst &amp; II, APInt DemandedMask, KnownBits &amp; Known, bool &amp; KnownBitsComputed)</code></pre>
                                <div>
                                    <div>
                                        <p> Can be used to implement target-specific instruction combining.</p>
                                    </div>
                                </div>
                                <p>Defined at line 384 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="4F0E017043A2FC73FFC85F5C4D9E0BCFC1B0DBE4">
                                <pre><code class="language-cpp code-clang-doc">std::optional&lt;Value *&gt; simplifyDemandedVectorEltsIntrinsic (InstCombiner &amp; IC, IntrinsicInst &amp; II, APInt DemandedElts, APInt &amp; UndefElts, APInt &amp; UndefElts2, APInt &amp; UndefElts3, std::function&lt;void (Instruction *, unsigned int, APInt, APInt &amp;)&gt; SimplifyAndSetOp)</code></pre>
                                <div>
                                    <div>
                                        <p> Can be used to implement target-specific instruction combining.</p>
                                    </div>
                                </div>
                                <p>Defined at line 391 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0654A614522B63B7394BDB6482CD36260B65B4C8">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalAddImmediate (int64_t Imm)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the specified immediate is legal add immediate, that</p>
                                        <p> is the target has add instructions which can add a register with the</p>
                                        <p> immediate without having to materialize the immediate into a register.</p>
                                    </div>
                                </div>
                                <p>Defined at line 412 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="01A36ECDD928E63C1FEE7BFF645DE8570611F1A7">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalAddScalableImmediate (int64_t Imm)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if adding the specified scalable immediate is legal, that is</p>
                                        <p> the target has add instructions which can add a register with the</p>
                                        <p> immediate (multiplied by vscale) without having to materialize the</p>
                                        <p> immediate into a register.</p>
                                    </div>
                                </div>
                                <p>Defined at line 416 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6950CEAE6E0DC126F4050D1B99FDB6782FCA7693">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalICmpImmediate (int64_t Imm)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the specified immediate is legal icmp immediate,</p>
                                        <p> that is the target has icmp instructions which can compare a register</p>
                                        <p> against the immediate without having to materialize the immediate into a</p>
                                        <p> register.</p>
                                    </div>
                                </div>
                                <p>Defined at line 420 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="19D99DB44F36AA98437AD5A8B63AE401C87158EE">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalAddressingMode (Type * Ty, GlobalValue * BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned int AddrSpace, Instruction * I, int64_t ScalableOffset)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the addressing mode represented by AM is legal for</p>
                                        <p> this target, for a load/store of the specified type.</p>
                                        <p> The type may be VoidTy, in which case only return true if the addressing</p>
                                        <p> mode is legal for a load/store of any legal type.</p>
                                        <p> If target returns true in LSRWithInstrQueries(), I may be valid.</p>
                                    </div>
                                    <div>
                                        <p> TODO: Handle pre/postinc as well.</p>
                                    </div>
                                    <h3>Parameters</h3>
                                    <div>
                                        <b>ScalableOffset</b>   represents a quantity of bytes multiplied by vscale, an invariant value known only at runtime. Most targets should not accept a scalable offset.
                                    </div> 
                                </div>
                                <p>Defined at line 424 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="3D1448391ED117F8550CDF76DBC04E27BA586342">
                                <pre><code class="language-cpp code-clang-doc">bool isLSRCostLess (const TargetTransformInfo::LSRCost &amp; C1, const TargetTransformInfo::LSRCost &amp; C2)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if LSR cost of C1 is lower than C2.</p>
                                    </div>
                                </div>
                                <p>Defined at line 434 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="17CEE7F55A243F08B15C43B34DE451FA570D070B">
                                <pre><code class="language-cpp code-clang-doc">bool isNumRegsMajorCostOfLSR ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if LSR major cost is number of registers. Targets which</p>
                                        <p> implement their own isLSRCostLess and unset number of registers as major</p>
                                        <p> cost should return false, otherwise return true.</p>
                                    </div>
                                </div>
                                <p>Defined at line 439 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="EC1A3B5A300B028F5D894F5989FC126BCDE7A95D">
                                <pre><code class="language-cpp code-clang-doc">bool shouldDropLSRSolutionIfLessProfitable ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if LSR should drop a found solution if it&#39;s calculated to be</p>
                                        <p> less profitable than the baseline.</p>
                                    </div>
                                </div>
                                <p>Defined at line 443 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="959EE991917921C618FB82F1C4D747E460429FE6">
                                <pre><code class="language-cpp code-clang-doc">bool isProfitableLSRChainElement (Instruction * I)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 447 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="DA1B40AA57B31BD896B31474C63776097C67E209">
                                <pre><code class="language-cpp code-clang-doc">bool canMacroFuseCmp ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target can fuse a compare and branch.</p>
                                        <p> Loop-strength-reduction (LSR) uses that knowledge to adjust its cost</p>
                                        <p> calculation for the instructions in a loop.</p>
                                    </div>
                                </div>
                                <p>Defined at line 451 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="4B91DCD4C207096A52E08CB9A5A99CF137AD3B77">
                                <pre><code class="language-cpp code-clang-doc">bool canSaveCmp (Loop * L, BranchInst ** BI, ScalarEvolution * SE, LoopInfo * LI, DominatorTree * DT, AssumptionCache * AC, TargetLibraryInfo * LibInfo)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target can save a compare for loop count, for example</p>
                                        <p> hardware loop saves a compare.</p>
                                    </div>
                                </div>
                                <p>Defined at line 455 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8DD921C81E6C45A15B5B198DB84BC273121D7C95">
                                <pre><code class="language-cpp code-clang-doc">AddressingModeKind getPreferredAddressingMode (const Loop * L, ScalarEvolution * SE)</code></pre>
                                <div>
                                    <div>
                                        <p> Return the preferred addressing mode LSR should make efforts to generate.</p>
                                    </div>
                                </div>
                                <p>Defined at line 462 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="80EF1BE1CAD69ED430583D363A6FE28DDE29CC81">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalMaskedStore (Type * DataType, Align Alignment, unsigned int AddressSpace, MaskKind MaskKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports masked store.</p>
                                    </div>
                                </div>
                                <p>Defined at line 468 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0C67147F5223CB3AE370E7793034EB43A33B338F">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalMaskedLoad (Type * DataType, Align Alignment, unsigned int AddressSpace, MaskKind MaskKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports masked load.</p>
                                    </div>
                                </div>
                                <p>Defined at line 475 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="B99A7F7235D8A0F0FA8864B797F7C22D38C8BA1B">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalNTStore (Type * DataType, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports nontemporal store.</p>
                                    </div>
                                </div>
                                <p>Defined at line 482 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2A4FB81FD2364AC9602504EAFC2FC38955D3FC2D">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalNTLoad (Type * DataType, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports nontemporal load.</p>
                                    </div>
                                </div>
                                <p>Defined at line 487 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="B6AA1360FF8632672A84DFDDE6CDD00AED94209F">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalBroadcastLoad (Type * ElementTy, ElementCount NumElements)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 491 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E523E0CB65E4A106151AE81192602F64E31383E2">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalMaskedScatter (Type * DataType, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports masked scatter.</p>
                                    </div>
                                </div>
                                <p>Defined at line 507 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="A8E8B9B05BCC90B67507F1105A0A5EACBAF23EF6">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalMaskedGather (Type * DataType, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports masked gather.</p>
                                    </div>
                                </div>
                                <p>Defined at line 496 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1D459293329806F779047C697ACB77BA2047EB79">
                                <pre><code class="language-cpp code-clang-doc">bool forceScalarizeMaskedGather (VectorType * Type, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target forces scalarizing of llvm.masked.gather</p>
                                        <p> intrinsics.</p>
                                    </div>
                                </div>
                                <p>Defined at line 512 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="65743EA3B0101B69EE14FABE326EB1E64D49E1F3">
                                <pre><code class="language-cpp code-clang-doc">bool forceScalarizeMaskedScatter (VectorType * Type, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target forces scalarizing of llvm.masked.scatter</p>
                                        <p> intrinsics.</p>
                                    </div>
                                </div>
                                <p>Defined at line 517 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="08E4ADE71EA4F501FB7C5CA077D52F234023E809">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalMaskedCompressStore (Type * DataType, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports masked compress store.</p>
                                    </div>
                                </div>
                                <p>Defined at line 522 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="822EEEDC63C4E51120815F55B802B0C16FA3209B">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalMaskedExpandLoad (Type * DataType, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports masked expand load.</p>
                                    </div>
                                </div>
                                <p>Defined at line 527 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F2D4F4EAF8731414D6A5CCAC197F08790FCE3A80">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalStridedLoadStore (Type * DataType, Align Alignment)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports strided load.</p>
                                    </div>
                                </div>
                                <p>Defined at line 532 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="A6596ABAF8C7C23C0B33F9601FB71BAA6E4F5433">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalInterleavedAccessType (VectorType * VTy, unsigned int Factor, Align Alignment, unsigned int AddrSpace)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true is the target supports interleaved access for the given vector</p>
                                        <p> type </p>
                                        <p> interleave factor </p>
                                        <p> alignment </p>
                                        <p> and</p>
                                        <p> address space </p>
                                    </div>
                                </div>
                                <p>Defined at line 537 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="9840B28C32620297DB5FB1F470050551A0A4FCE2">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalMaskedVectorHistogram (Type * AddrType, Type * DataType)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target supports masked vector histograms.</p>
                                    </div>
                                </div>
                                <p>Defined at line 544 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5270D569E4C98F81AC0607199319A66D6A6DCDAE">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalAltInstr (VectorType * VecTy, unsigned int Opcode0, unsigned int Opcode1, const SmallBitVector &amp; OpcodeMask)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if this is an alternating opcode pattern that can be lowered</p>
                                        <p> to a single instruction on the target. In X86 this is for the addsub</p>
                                        <p> instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.</p>
                                        <p> This function expectes two opcodes: </p>
                                        <p> and </p>
                                        <p> being</p>
                                        <p> selected by </p>
                                        <p> The mask contains one bit per lane and is a `0`</p>
                                        <p> when </p>
                                        <p> is selected and `1` when Opcode1 is selected.</p>
                                        <p> is the vector type of the instruction to be generated.</p>
                                    </div>
                                </div>
                                <p>Defined at line 501 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0FAE6450FA400B7ACE8BFB57848A1C015982DE1E">
                                <pre><code class="language-cpp code-clang-doc">bool enableOrderedReductions ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if we should be enabling ordered reductions for the target.</p>
                                    </div>
                                </div>
                                <p>Defined at line 549 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1509C06674F2D23AF842043CF4CD7F39262A6BD8">
                                <pre><code class="language-cpp code-clang-doc">bool hasDivRemOp (Type * DataType, bool IsSigned)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the target has a unified operation to calculate division</p>
                                        <p> and remainder. If so, the additional implicit multiplication and</p>
                                        <p> subtraction required to calculate a remainder from division are free. This</p>
                                        <p> can enable more aggressive transformations for division and remainder than</p>
                                        <p> would typically be allowed using throughput or size cost models.</p>
                                    </div>
                                </div>
                                <p>Defined at line 553 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="470632B01532833B2B9F68D9DEF6433B19A5AD4F">
                                <pre><code class="language-cpp code-clang-doc">bool hasVolatileVariant (Instruction * I, unsigned int AddrSpace)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the given instruction (assumed to be a memory access</p>
                                        <p> instruction) has a volatile variant. If that&#39;s the case then we can avoid</p>
                                        <p> addrspacecast to generic AS for volatile loads/stores. Default</p>
                                        <p> implementation returns false, which prevents address space inference for</p>
                                        <p> volatile loads/stores.</p>
                                    </div>
                                </div>
                                <p>Defined at line 557 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6ADB716E1DBAE09581DE0C7200F14FBC2425267E">
                                <pre><code class="language-cpp code-clang-doc">bool prefersVectorizedAddressing ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if target doesn&#39;t mind addresses in vectors.</p>
                                    </div>
                                </div>
                                <p>Defined at line 562 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5B52611FEEB82C748DE331A88BBA55AE231AC35C">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getScalingFactorCost (Type * Ty, GlobalValue * BaseGV, StackOffset BaseOffset, bool HasBaseReg, int64_t Scale, unsigned int AddrSpace)</code></pre>
                                <div>
                                    <div>
                                        <p> Return the cost of the scaling factor used in the addressing</p>
                                        <p> mode represented by AM for this target, for a load/store</p>
                                        <p> of the specified type.</p>
                                        <p> If the AM is supported, the return value must be &gt;= 0.</p>
                                        <p> If the AM is not supported, it returns a negative value.</p>
                                        <p> TODO: Handle pre/postinc as well.</p>
                                    </div>
                                </div>
                                <p>Defined at line 566 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6B3A3BE5152A6CA6E551B67E2404F62ABA3CA225">
                                <pre><code class="language-cpp code-clang-doc">bool LSRWithInstrQueries ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the loop strength reduce pass should make</p>
                                        <p> Instruction* based TTI queries to isLegalAddressingMode(). This is</p>
                                        <p> needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned</p>
                                        <p> immediate offset and no index register.</p>
                                    </div>
                                </div>
                                <p>Defined at line 575 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="D2660BF64050480B9E18FB04CC2B2DFAEA0196C6">
                                <pre><code class="language-cpp code-clang-doc">bool isTruncateFree (Type * Ty1, Type * Ty2)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if it&#39;s free to truncate a value of type Ty1 to type</p>
                                        <p> Ty2. e.g. On x86 it&#39;s free to truncate a i32 value in register EAX to i16</p>
                                        <p> by referencing its sub-register AX.</p>
                                    </div>
                                </div>
                                <p>Defined at line 579 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="66CE702F886C1A3A0DF1611842368C87D10D22E3">
                                <pre><code class="language-cpp code-clang-doc">bool isProfitableToHoist (Instruction * I)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if it is profitable to hoist instruction in the</p>
                                        <p> then/else to before if.</p>
                                    </div>
                                </div>
                                <p>Defined at line 583 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="25F28670075C18AE9A6C6C197EC0273D0ABBE1E9">
                                <pre><code class="language-cpp code-clang-doc">bool useAA ()</code></pre>
                                <p>Defined at line 587 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="59A7D324CF57E12B9A1656609B3D6761C556F554">
                                <pre><code class="language-cpp code-clang-doc">bool isTypeLegal (Type * Ty)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if this type is legal.</p>
                                    </div>
                                </div>
                                <p>Defined at line 589 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="ACB5FAAD486D7EEADF5435D3E76945D0BCD22FE4">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getRegUsageForType (Type * Ty)</code></pre>
                                <div>
                                    <div>
                                        <p> Returns the estimated number of registers required to represent </p>
                                    </div>
                                </div>
                                <p>Defined at line 593 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="FC9C9AB1607B3C38354B8AC10B79A9896AD6532A">
                                <pre><code class="language-cpp code-clang-doc">bool shouldBuildLookupTables ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if switches should be turned into lookup tables for the</p>
                                        <p> target.</p>
                                    </div>
                                </div>
                                <p>Defined at line 597 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="7737D117EC575AF463350904BDB06C010AD40945">
                                <pre><code class="language-cpp code-clang-doc">bool shouldBuildLookupTablesForConstant (Constant * C)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if switches should be turned into lookup tables</p>
                                        <p> containing this constant value for the target.</p>
                                    </div>
                                </div>
                                <p>Defined at line 601 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="14DEBAEDC876122B6EE939FD709BA4721348D2D9">
                                <pre><code class="language-cpp code-clang-doc">bool shouldBuildRelLookupTables ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if lookup tables should be turned into relative lookup tables.</p>
                                    </div>
                                </div>
                                <p>Defined at line 606 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="3DA4859DFBC7979084FA1A6ED2038D42879B2CA4">
                                <pre><code class="language-cpp code-clang-doc">bool useColdCCForColdCall (Function &amp; F)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the input function which is cold at all call sites,</p>
                                        <p>  should use coldcc calling convention.</p>
                                    </div>
                                </div>
                                <p>Defined at line 610 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="68C5BD87A045B4F3D347439D84B79544F2C3E630">
                                <pre><code class="language-cpp code-clang-doc">bool useFastCCForInternalCall (Function &amp; F)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the input function is internal, should use fastcc calling</p>
                                        <p> convention.</p>
                                    </div>
                                </div>
                                <p>Defined at line 614 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="DA222EA2C5042F322FE52E365A10E5D7966D49A0">
                                <pre><code class="language-cpp code-clang-doc">bool isTargetIntrinsicTriviallyScalarizable (Intrinsic::ID ID)</code></pre>
                                <p>Defined at line 618 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E85599A95B3298DC50465350E95FD1EF745C0E26">
                                <pre><code class="language-cpp code-clang-doc">bool isTargetIntrinsicWithScalarOpAtArg (Intrinsic::ID ID, unsigned int ScalarOpdIdx)</code></pre>
                                <div>
                                    <div>
                                        <p> Identifies if the vector form of the intrinsic has a scalar operand.</p>
                                    </div>
                                </div>
                                <p>Defined at line 623 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="18D76602BEC9F4E85BCF3F19B19C43B218E79EE1">
                                <pre><code class="language-cpp code-clang-doc">bool isTargetIntrinsicWithOverloadTypeAtArg (Intrinsic::ID ID, int OpdIdx)</code></pre>
                                <div>
                                    <div>
                                        <p> Identifies if the vector form of the intrinsic is overloaded on the type</p>
                                        <p> of the operand at index </p>
                                        <p> or on the return type if </p>
                                        <p> is</p>
                                        <p> -1.</p>
                                    </div>
                                </div>
                                <p>Defined at line 628 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2D69EBCDB270C7B9F79A52D9DA055AAF3BAAC06A">
                                <pre><code class="language-cpp code-clang-doc">bool isTargetIntrinsicWithStructReturnOverloadAtField (Intrinsic::ID ID, int RetIdx)</code></pre>
                                <div>
                                    <div>
                                        <p> Identifies if the vector form of the intrinsic that returns a struct is</p>
                                        <p> overloaded at the struct element index </p>
                                    </div>
                                </div>
                                <p>Defined at line 633 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="C04B1BA493A8F9D3B3EC51117EFC061FB3C50D17">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getScalarizationOverhead (VectorType * Ty, const APInt &amp; DemandedElts, bool Insert, bool Extract, TargetCostKind CostKind, bool ForPoisonSrc, ArrayRef VL)</code></pre>
                                <div>
                                    <div>
                                        <p> Estimate the overhead of scalarizing an instruction. Insert and Extract</p>
                                        <p> are set if the demanded result elements need to be inserted and/or</p>
                                        <p> extracted from vectors.  The involved values may be passed in VL if</p>
                                        <p> Insert is true.</p>
                                    </div>
                                </div>
                                <p>Defined at line 638 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="71279EA7F79A02F876B12A554856BC87F8CA02C6">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getOperandsScalarizationOverhead (ArrayRef Tys, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Estimate the overhead of scalarizing operands with the given types. The</p>
                                        <p> (potentially vector) types to use for each of argument are passes via Tys.</p>
                                    </div>
                                </div>
                                <p>Defined at line 646 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="4BF608B70FA54DA10CA1E935DE0C548F6725ABEB">
                                <pre><code class="language-cpp code-clang-doc">bool supportsEfficientVectorElementLoadStore ()</code></pre>
                                <div>
                                    <div>
                                        <p> If target has efficient vector element load/store instructions, it can</p>
                                        <p> return true here so that insertion/extraction costs are not added to</p>
                                        <p> the scalarization cost of a load/store.</p>
                                    </div>
                                </div>
                                <p>Defined at line 651 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="BE866D59D6BE783A49523FF47FC1E405890876D6">
                                <pre><code class="language-cpp code-clang-doc">bool supportsTailCalls ()</code></pre>
                                <div>
                                    <div>
                                        <p> If the target supports tail calls.</p>
                                    </div>
                                </div>
                                <p>Defined at line 655 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6871B12279D9C1CD335E1679E92FC45C1F3BDFE4">
                                <pre><code class="language-cpp code-clang-doc">bool supportsTailCallFor (const CallBase * CB)</code></pre>
                                <div>
                                    <div>
                                        <p> If target supports tail call on </p>
                                    </div>
                                </div>
                                <p>Defined at line 659 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1C13CD1DA4E9952487A8785E5BB6E9CA76E383D5">
                                <pre><code class="language-cpp code-clang-doc">bool enableAggressiveInterleaving (bool LoopHasReductions)</code></pre>
                                <div>
                                    <div>
                                        <p> Don&#39;t restrict interleaved unrolling to small loops.</p>
                                    </div>
                                </div>
                                <p>Defined at line 663 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="B2CAD04698A2DE20606FE59F9E0C80D0E1733E7F">
                                <pre><code class="language-cpp code-clang-doc">MemCmpExpansionOptions enableMemCmpExpansion (bool OptSize, bool IsZeroCmp)</code></pre>
                                <p>Defined at line 668 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="96A7C8BE9AC807CDCA128EE81BE5373A22E1F83C">
                                <pre><code class="language-cpp code-clang-doc">bool enableSelectOptimize ()</code></pre>
                                <div>
                                    <div>
                                        <p> Should the Select Optimization pass be enabled and ran.</p>
                                    </div>
                                </div>
                                <p>Defined at line 673 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="9DD5D720DDF1172C8135208B539A2F4AB57050FD">
                                <pre><code class="language-cpp code-clang-doc">bool shouldTreatInstructionLikeSelect (const Instruction * I)</code></pre>
                                <div>
                                    <div>
                                        <p> Should the Select Optimization pass treat the given instruction like a</p>
                                        <p> select, potentially converting it to a conditional branch. This can</p>
                                        <p> include select-like instructions like or(zext(c), x) that can be converted</p>
                                        <p> to selects.</p>
                                    </div>
                                </div>
                                <p>Defined at line 677 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E50E8FB5153F0C35E5B431C31ACE02492189CF17">
                                <pre><code class="language-cpp code-clang-doc">bool enableInterleavedAccessVectorization ()</code></pre>
                                <div>
                                    <div>
                                        <p> Enable matching of interleaved access groups.</p>
                                    </div>
                                </div>
                                <p>Defined at line 682 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="A3D3FFDAB5544AA3777DAAFE92F11B09DBC63EB0">
                                <pre><code class="language-cpp code-clang-doc">bool enableMaskedInterleavedAccessVectorization ()</code></pre>
                                <div>
                                    <div>
                                        <p> Enable matching of interleaved access groups that contain predicated</p>
                                        <p> accesses or gaps and therefore vectorized using masked</p>
                                        <p> vector loads/stores.</p>
                                    </div>
                                </div>
                                <p>Defined at line 686 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="99BF237FA602D88FF2B1A25991370D8722553BEB">
                                <pre><code class="language-cpp code-clang-doc">bool isFPVectorizationPotentiallyUnsafe ()</code></pre>
                                <div>
                                    <div>
                                        <p> Indicate that it is potentially unsafe to automatically vectorize</p>
                                        <p> floating-point operations because the semantics of vector and scalar</p>
                                        <p> floating-point semantics may differ. For example, ARM NEON v7 SIMD math</p>
                                        <p> does not support IEEE-754 denormal numbers, while depending on the</p>
                                        <p> platform, scalar floating-point math does.</p>
                                        <p> This applies to floating-point math operations and calls, not memory</p>
                                        <p> operations, shuffles, or casts.</p>
                                    </div>
                                </div>
                                <p>Defined at line 690 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="045458F8E1A0C3C7E295108A9524ECC89D7C4CCD">
                                <pre><code class="language-cpp code-clang-doc">bool allowsMisalignedMemoryAccesses (LLVMContext &amp; Context, unsigned int BitWidth, unsigned int AddressSpace, Align Alignment, unsigned int * Fast)</code></pre>
                                <div>
                                    <div>
                                        <p> Determine if the target supports unaligned memory accesses.</p>
                                    </div>
                                </div>
                                <p>Defined at line 694 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="7BB76D9C68CEC85830663E197B54E446305B1F6A">
                                <pre><code class="language-cpp code-clang-doc">PopcntSupportKind getPopcntSupport (unsigned int IntTyWidthInBit)</code></pre>
                                <div>
                                    <div>
                                        <p> Return hardware support for population count.</p>
                                    </div>
                                </div>
                                <p>Defined at line 704 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="7BE509CC0102BDF250056DB1B9F2AD54447C5CC6">
                                <pre><code class="language-cpp code-clang-doc">bool haveFastSqrt (Type * Ty)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the hardware has a fast square-root instruction.</p>
                                    </div>
                                </div>
                                <p>Defined at line 709 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2F26C9BD0B4A683BC2C1E6F593D922D56AF8656C">
                                <pre><code class="language-cpp code-clang-doc">bool isExpensiveToSpeculativelyExecute (const Instruction * I)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the cost of the instruction is too high to speculatively</p>
                                        <p> execute and should be kept behind a branch.</p>
                                        <p> This normally just wraps around a getInstructionCost() call, but some</p>
                                        <p> targets might report a low TCK_SizeAndLatency value that is incompatible</p>
                                        <p> with the fixed TCC_Expensive value.</p>
                                        <p> NOTE: This assumes the instruction passes isSafeToSpeculativelyExecute().</p>
                                    </div>
                                </div>
                                <p>Defined at line 713 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5779780134073ABEC90FD5570D13481409A624DA">
                                <pre><code class="language-cpp code-clang-doc">bool isFCmpOrdCheaperThanFCmpZero (Type * Ty)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if it is faster to check if a floating-point value is NaN</p>
                                        <p> (or not-NaN) versus a comparison against a constant FP zero value.</p>
                                        <p> Targets should override this if materializing a 0.0 for comparison is</p>
                                        <p> generally as cheap as checking for ordered/unordered.</p>
                                    </div>
                                </div>
                                <p>Defined at line 718 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="54C1642AA7DAF1E6478CC938843186E611529206">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getFPOpCost (Type * Ty)</code></pre>
                                <div>
                                    <div>
                                        <p> Return the expected cost of supporting the floating point operation</p>
                                        <p> of the specified type.</p>
                                    </div>
                                </div>
                                <p>Defined at line 722 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0904112798377032024705753C79DD6B9949BFE2">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getIntImmCost (const APInt &amp; Imm, Type * Ty, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Return the expected cost of materializing for the given integer</p>
                                        <p> immediate of the specified type.</p>
                                    </div>
                                </div>
                                <p>Defined at line 737 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="C45881E0853AC7039C7EBF115755B3CD1CBF234D">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getIntImmCostInst (unsigned int Opc, unsigned int Idx, const APInt &amp; Imm, Type * Ty, TargetCostKind CostKind, Instruction * Inst)</code></pre>
                                <div>
                                    <div>
                                        <p> Return the expected cost of materialization for the given integer</p>
                                        <p> immediate of the specified type for a given instruction. The cost can be</p>
                                        <p> zero if the immediate can be folded into the specified instruction.</p>
                                    </div>
                                </div>
                                <p>Defined at line 745 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="468983B937EE5DBAC3943F0928CCF6995A841B40">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getIntImmCostIntrin (Intrinsic::ID IID, unsigned int Idx, const APInt &amp; Imm, Type * Ty, TargetCostKind CostKind)</code></pre>
                                <p>Defined at line 754 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="ADCECDFE4075E78576975C6B657EF71CF6FD3151">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getIntImmCodeSizeCost (unsigned int Opc, unsigned int Idx, const APInt &amp; Imm, Type * Ty)</code></pre>
                                <div>
                                    <div>
                                        <p> Return the expected cost for the given integer when optimising</p>
                                        <p> for size. This is different than the other integer immediate cost</p>
                                        <p> functions in that it is subtarget agnostic. This is useful when you e.g.</p>
                                        <p> target one ISA such as Aarch32 but smaller encodings could be possible</p>
                                        <p> with another such as Thumb. This return value is used as a penalty when</p>
                                        <p> the total costs for a constant is calculated (the bigger the cost, the</p>
                                        <p> more beneficial constant hoisting is).</p>
                                    </div>
                                </div>
                                <p>Defined at line 728 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="175A5EB7656868CE765124A76E648308AF07C9E5">
                                <pre><code class="language-cpp code-clang-doc">bool preferToKeepConstantsAttached (const Instruction &amp; Inst, const Function &amp; Fn)</code></pre>
                                <div>
                                    <div>
                                        <p> It can be advantageous to detach complex constants from their uses to make</p>
                                        <p> their generation cheaper. This hook allows targets to report when such</p>
                                        <p> transformations might negatively effect the code generation of the</p>
                                        <p> underlying operation. The motivating example is divides whereby hoisting</p>
                                        <p> constants prevents the code generator&#39;s ability to transform them into</p>
                                        <p> combinations of simpler operations.</p>
                                    </div>
                                </div>
                                <p>Defined at line 764 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8B89174B1442F6CB687E4E21A1A96F1046777BF0">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getNumberOfRegisters (unsigned int ClassID)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> the number of registers in the target-provided register class.</p>
                                </div>
                                <p>Defined at line 769 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="3DD1FCAEC2FA3D8A24CE4A88AA58DBDF4C41A1BD">
                                <pre><code class="language-cpp code-clang-doc">bool hasConditionalLoadStoreForType (Type * Ty, bool IsStore)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> true if the target supports load/store that enables fault</p>
                                    <p> suppression of memory operands when the source condition is false.</p>
                                </div>
                                <p>Defined at line 773 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5F28032E8382173C98C13C386D8FE3EC18AD6E05">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getRegisterClassForType (bool Vector, Type * Ty)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> the target-provided register class ID for the provided type,</p>
                                    <p> accounting for type promotion and other type-legalization techniques that</p>
                                    <p> the target might apply. However, it specifically does not account for the</p>
                                    <p> scalarization or splitting of vector types. Should a vector type require</p>
                                    <p> scalarization or splitting into multiple underlying vector registers, that</p>
                                    <p> type should be mapped to a register class containing no registers.</p>
                                    <p> Specifically, this is designed to provide a simple, high-level view of the</p>
                                    <p> register allocation later performed by the backend. These register classes</p>
                                    <p> don&#39;t necessarily map onto the register classes used by the backend.</p>
                                    <p> FIXME: It&#39;s not currently possible to determine how many registers</p>
                                    <p> are used by the provided type.</p>
                                </div>
                                <p>Defined at line 778 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2719AEE9D307EB2BA34891984945E3D90225CB3D">
                                <pre><code class="language-cpp code-clang-doc">const char * getRegisterClassName (unsigned int ClassID)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> the target-provided register class name</p>
                                </div>
                                <p>Defined at line 783 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E0B0CCA79ED22273A0B9525AA577A1E1A5D134E8">
                                <pre><code class="language-cpp code-clang-doc">TypeSize getRegisterBitWidth (RegisterKind K)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The width of the largest scalar or vector register type.</p>
                                </div>
                                <p>Defined at line 787 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1459280368AA397002107042D474ED0C88D44785">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getMinVectorRegisterBitWidth ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The width of the smallest vector register type.</p>
                                </div>
                                <p>Defined at line 792 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="BAB6BEDB5E7AC78E2008FA81BB4667E4D5D70757">
                                <pre><code class="language-cpp code-clang-doc">optional getMaxVScale ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The maximum value of vscale if the target specifies an</p>
                                    <p>  architectural maximum vector length, and std::nullopt otherwise.</p>
                                </div>
                                <p>Defined at line 796 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="783735AD87EFD07E35B21FCFE6F28430265A2E3E">
                                <pre><code class="language-cpp code-clang-doc">optional getVScaleForTuning ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> the value of vscale to tune the cost model for.</p>
                                </div>
                                <p>Defined at line 800 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="66599CA57AAE964308F9C22C5D45881D7ECF7EAB">
                                <pre><code class="language-cpp code-clang-doc">bool isVScaleKnownToBeAPowerOfTwo ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> true if vscale is known to be a power of 2</p>
                                </div>
                                <p>Defined at line 804 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="AA62F2CA2A713144177ABE6E79B0F251C8512410">
                                <pre><code class="language-cpp code-clang-doc">bool shouldMaximizeVectorBandwidth (RegisterKind K)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> True if the vectorization factor should be chosen to</p>
                                    <p> make the vector of the smallest element type match the size of a</p>
                                    <p> vector register. For wider element types, this could result in</p>
                                    <p> creating vectors that span multiple vector registers.</p>
                                    <p> If false, the vectorization factor will be chosen based on the</p>
                                    <p> size of the widest element type.</p>
                                    <p> Register Kind for vectorization.</p>
                                </div>
                                <p>Defined at line 808 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="87C5D3BFB0EBB741EAD376D735A9DDA0795E0104">
                                <pre><code class="language-cpp code-clang-doc">ElementCount getMinimumVF (unsigned int ElemWidth, bool IsScalable)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The minimum vectorization factor for types of given element</p>
                                    <p> bit width, or 0 if there is no minimum VF. The returned value only</p>
                                    <p> applies when shouldMaximizeVectorBandwidth returns true.</p>
                                    <p> If IsScalable is true, the returned ElementCount must be a scalable VF.</p>
                                </div>
                                <p>Defined at line 813 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="93B15180881925FC1D4ED3718D203F46922EE0D1">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getMaximumVF (unsigned int ElemWidth, unsigned int Opcode)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The maximum vectorization factor for types of given element</p>
                                    <p> bit width and opcode, or 0 if there is no maximum VF.</p>
                                    <p> Currently only used by the SLP vectorizer.</p>
                                </div>
                                <p>Defined at line 818 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="A1E141BD19344E1440D103813EE0717B00745821">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getStoreMinimumVF (unsigned int VF, Type * ScalarMemTy, Type * ScalarValTy)</code></pre>
                                <div>
                                    <h3>Parameters</h3>
                                    <div>
                                        <b>VF</b>   Initial estimation of the minimum vector factor.
                                    </div> 
                                    <div>
                                        <b>ScalarMemTy</b>   Scalar memory type of the store operation.
                                    </div> 
                                    <div>
                                        <b>ScalarValTy</b>   Scalar type of the stored value. Currently only used by the SLP vectorizer.
                                    </div> 
                                    <h3>Returns</h3>
                                    <p> The minimum vectorization factor for the store instruction. Given</p>
                                    <p> the initial estimation of the minimum vector factor and store value type,</p>
                                    <p> it tries to find possible lowest VF, which still might be profitable for</p>
                                    <p> the vectorization.</p>
                                </div>
                                <p>Defined at line 823 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="AAAF4C1EA3B4354310504000D80FA599F56AA827">
                                <pre><code class="language-cpp code-clang-doc">bool shouldConsiderAddressTypePromotion (const Instruction &amp; I, bool &amp; AllowPromotionWithoutCommonHeader)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> True if it should be considered for address type promotion.</p>
                                    <p> Set true if promoting </p>
                                    <p> is</p>
                                    <p> profitable without finding other extensions fed by the same input.</p>
                                </div>
                                <p>Defined at line 828 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="9FEEAC82B37D172FB01A7D9DD1AA5CF23018B3F8">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getCacheLineSize ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The size of a cache line in bytes.</p>
                                </div>
                                <p>Defined at line 834 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="3D818AD87874406079A82EE7ED4DA9F4729DBE62">
                                <pre><code class="language-cpp code-clang-doc">optional getCacheSize (CacheLevel Level)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The size of the cache level in bytes, if available.</p>
                                </div>
                                <p>Defined at line 839 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="AA1B6D960B2D9CAE2DCE57F737C75C7B5C1F88AA">
                                <pre><code class="language-cpp code-clang-doc">optional getCacheAssociativity (CacheLevel Level)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The associativity of the cache level, if available.</p>
                                </div>
                                <p>Defined at line 844 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F78F750E9EC321080A460710DAD4D22C476C0F61">
                                <pre><code class="language-cpp code-clang-doc">optional getMinPageSize ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The minimum architectural page size for the target.</p>
                                </div>
                                <p>Defined at line 849 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2122C900E508F924205AD704619684B23AFF621A">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getPrefetchDistance ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> How much before a load we should place the prefetch</p>
                                    <p> instruction.  This is currently measured in number of</p>
                                    <p> instructions.</p>
                                </div>
                                <p>Defined at line 854 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="72721B1D5B395CC6326F707115F338392FC4ED87">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getMinPrefetchStride (unsigned int NumMemAccesses, unsigned int NumStridedMemAccesses, unsigned int NumPrefetches, bool HasCall)</code></pre>
                                <div>
                                    <div>
                                        <p> Some HW prefetchers can handle accesses up to a certain constant stride.</p>
                                        <p> Sometimes prefetching is beneficial even below the HW prefetcher limit,</p>
                                        <p> and the arguments provided are meant to serve as a basis for deciding this</p>
                                        <p> for a particular loop.</p>
                                    </div>
                                    <h3>Parameters</h3>
                                    <div>
                                        <b>NumMemAccesses</b>          Number of memory accesses in the loop.
                                    </div> 
                                    <div>
                                        <b>NumStridedMemAccesses</b>   Number of the memory accesses that                              ScalarEvolution could find a known stride                              for.
                                    </div> 
                                    <div>
                                        <b>NumPrefetches</b>           Number of software prefetches that will be                              emitted as determined by the addresses                              involved and the cache line size.
                                    </div> 
                                    <div>
                                        <b>HasCall</b>                 True if the loop contains a call.
                                    </div> 
                                    <h3>Returns</h3>
                                    <p> This is the minimum stride in bytes where it makes sense to start</p>
                                    <p>         adding SW prefetches. The default is 1, i.e. prefetch with any</p>
                                    <p>         stride.</p>
                                </div>
                                <p>Defined at line 858 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="EC0ACABF5812853617EF709E1B1311EEF204035D">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getMaxPrefetchIterationsAhead ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The maximum number of iterations to prefetch ahead.  If</p>
                                    <p> the required number of iterations is more than this number, no</p>
                                    <p> prefetching is performed.</p>
                                </div>
                                <p>Defined at line 865 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="D69432CACC95100E046C9028179BC898A8DBA3B1">
                                <pre><code class="language-cpp code-clang-doc">bool enableWritePrefetching ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> True if prefetching should also be done for writes.</p>
                                </div>
                                <p>Defined at line 869 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="17BC2244BB969E8211DAFEC787BB7A3CBBCA85D2">
                                <pre><code class="language-cpp code-clang-doc">bool shouldPrefetchAddressSpace (unsigned int AS)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> if target want to issue a prefetch in address space </p>
                                </div>
                                <p>Defined at line 873 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="DC167F816FEC24447B187EFF0AADCC0D10C52329">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getPartialReductionCost (unsigned int Opcode, Type * InputTypeA, Type * InputTypeB, Type * AccumType, ElementCount VF, PartialReductionExtendKind OpAExtend, PartialReductionExtendKind OpBExtend, optional BinOp, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The cost of a partial reduction, which is a reduction from a</p>
                                    <p> vector to another vector with fewer elements of larger size. They are</p>
                                    <p> represented by the llvm.vector.partial.reduce.add intrinsic, which</p>
                                    <p> takes an accumulator of type </p>
                                    <p> and a second vector operand to</p>
                                    <p> be accumulated, whose element count is specified by </p>
                                    <p> The type of</p>
                                    <p> reduction is specified by </p>
                                    <p> The second operand passed to the</p>
                                    <p> intrinsic could be the result of an extend, such as sext or zext. In</p>
                                    <p> this case </p>
                                    <p> is nullopt, </p>
                                    <p> represents the type being</p>
                                    <p> extended and </p>
                                    <p> the operation, i.e. sign- or zero-extend.</p>
                                    <p> Also, </p>
                                    <p> should be nullptr and OpBExtend should be None.</p>
                                    <p> Alternatively, the second operand could be the result of a binary</p>
                                    <p> operation performed on two extends, i.e.</p>
                                    <p>   mul(zext i8 %a -&gt; i32, zext i8 %b -&gt; i32).</p>
                                    <p> In this case </p>
                                    <p> may specify the opcode of the binary operation,</p>
                                    <p> and </p>
                                    <p> the types being extended, and</p>
                                    <p> the form of extensions. An example of an</p>
                                    <p> operation that uses a partial reduction is a dot product, which reduces</p>
                                    <p> two vectors in binary mul operation to another of 4 times fewer and 4</p>
                                    <p> times larger elements.</p>
                                </div>
                                <p>Defined at line 877 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="25986C0784E67827FAECB8BB62BAA5F50ABC4624">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getMaxInterleaveFactor (ElementCount VF)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The maximum interleave factor that any transform should try to</p>
                                    <p> perform for this target. This number depends on the level of parallelism</p>
                                    <p> and the number of execution units in the CPU.</p>
                                </div>
                                <p>Defined at line 887 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F7FA40FF21BCCE1655F5F8C6462660E4C67E8113">
                                <pre><code class="language-cpp code-clang-doc">OperandValueInfo getOperandInfo (const Value * V)</code></pre>
                                <div>
                                    <div>
                                        <p> Collect properties of V used in cost analysis, e.g. OP_PowerOf2.</p>
                                    </div>
                                </div>
                                <p>Defined at line 891 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="FF1281FCBB438E2F2D6FB0EEA0CA196358368F62">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getArithmeticInstrCost (unsigned int Opcode, Type * Ty, TargetCostKind CostKind, OperandValueInfo Opd1Info, OperandValueInfo Opd2Info, ArrayRef Args, const Instruction * CxtI, const TargetLibraryInfo * TLibInfo)</code></pre>
                                <div>
                                    <div>
                                        <p> This is an approximation of reciprocal throughput of a math/logic op.</p>
                                        <p> A higher cost indicates less expected throughput.</p>
                                        <p> From Agner Fog&#39;s guides, reciprocal throughput is &quot;the average number of</p>
                                        <p> clock cycles per instruction when the instructions are not part of a</p>
                                        <p> limiting dependency chain.&quot;</p>
                                        <p> Therefore, costs should be scaled to account for multiple execution units</p>
                                        <p> on the target that can process this type of instruction. For example, if</p>
                                        <p> there are 5 scalar integer units and 2 vector integer units that can</p>
                                        <p> calculate an &#39;add&#39; in a single cycle, this model should indicate that the</p>
                                        <p> cost of the vector add instruction is 2.5 times the cost of the scalar</p>
                                        <p> add instruction.</p>
                                        <p> is an optional argument which holds the instruction operands</p>
                                        <p> values so the TTI can analyze those values searching for special</p>
                                        <p> cases or optimizations based on those values.</p>
                                        <p> is the optional original context instruction, if one exists, to</p>
                                        <p> provide even more information.</p>
                                        <p> is used to search for platform specific vector library</p>
                                        <p> functions for instructions that might be converted to calls (e.g. frem).</p>
                                    </div>
                                </div>
                                <p>Defined at line 957 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="68B0482974D178C91F826B2DD2BB23158E23DDE5">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getAltInstrCost (VectorType * VecTy, unsigned int Opcode0, unsigned int Opcode1, const SmallBitVector &amp; OpcodeMask, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Returns the cost estimation for alternating opcode pattern that can be</p>
                                        <p> lowered to a single instruction on the target. In X86 this is for the</p>
                                        <p> addsub instruction which corrsponds to a Shuffle + Fadd + FSub pattern in</p>
                                        <p> IR. This function expects two opcodes: </p>
                                        <p> and </p>
                                        <p> being</p>
                                        <p> selected by </p>
                                        <p> The mask contains one bit per lane and is a `0`</p>
                                        <p> when </p>
                                        <p> is selected and `1` when Opcode1 is selected.</p>
                                        <p> is the vector type of the instruction to be generated.</p>
                                    </div>
                                </div>
                                <p>Defined at line 984 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F143F2486E33C21ED2B6FDADB46EC3A047D13235">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getShuffleCost (ShuffleKind Kind, VectorType * DstTy, VectorType * SrcTy, ArrayRef Mask, TargetCostKind CostKind, int Index, VectorType * SubTp, ArrayRef Args, const Instruction * CxtI)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The cost of a shuffle instruction of kind Kind with inputs of type</p>
                                    <p> SrcTy, producing a vector of type DstTy. The exact mask may be passed as</p>
                                    <p> Mask, or else the array will be empty. The Index and SubTp parameters</p>
                                    <p> are used by the subvector insertions shuffle kinds to show the insert</p>
                                    <p> point and the type of the subvector being inserted. The operands of the</p>
                                    <p> shuffle can be passed through </p>
                                    <p> which helps improve the cost</p>
                                    <p> estimation in some cases, like in broadcast loads.</p>
                                </div>
                                <p>Defined at line 993 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2172E5A529F2DEF92DBF6BAEFB9CD91BBD377347">
                                <pre><code class="language-cpp code-clang-doc">CastContextHint getCastContextHint (const Instruction * I)</code></pre>
                                <div>
                                    <div>
                                        <p> Calculates a CastContextHint from </p>
                                        <p> This should be used by callers of getCastInstrCost if they wish to</p>
                                        <p> determine the context from some instruction.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1029 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="EABE93253F4F9EC7782DF1931091CFD53D381781">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getCastInstrCost (unsigned int Opcode, Type * Dst, Type * Src, CastContextHint CCH, TargetCostKind CostKind, const Instruction * I)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The expected cost of cast instructions, such as bitcast, trunc,</p>
                                    <p> zext, etc. If there is an existing instruction that holds Opcode, it</p>
                                    <p> may be passed in the &#39;I&#39; parameter.</p>
                                </div>
                                <p>Defined at line 1073 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F9783F6265F63F778B92CC798B27CE83325C849B">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getExtractWithExtendCost (unsigned int Opcode, Type * Dst, VectorType * VecTy, unsigned int Index, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The expected cost of a sign- or zero-extended vector extract. Use</p>
                                    <p> Index = -1 to indicate that there is no information about the index value.</p>
                                </div>
                                <p>Defined at line 1084 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="409D2CF5BC565D3D4F59FEEA768A9B2B958E3138">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getCFInstrCost (unsigned int Opcode, TargetCostKind CostKind, const Instruction * I)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The expected cost of control-flow related instructions such as</p>
                                    <p> Phi, Ret, Br, Switch.</p>
                                </div>
                                <p>Defined at line 1093 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="693C3F52D4E57E0144FA0CF90DD3A51BAFC4C91C">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getCmpSelInstrCost (unsigned int Opcode, Type * ValTy, Type * CondTy, Predicate VecPred, TargetCostKind CostKind, OperandValueInfo Op1Info, OperandValueInfo Op2Info, const Instruction * I)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1102 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="24C61247DBD4891A7D708284617440DA36BBE1C1">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getVectorInstrCost (unsigned int Opcode, Type * Val, TargetCostKind CostKind, unsigned int Index, const Value * Op0, const Value * Op1)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The expected cost of vector Insert and Extract.</p>
                                    <p> Use -1 to indicate that there is no information on the index value.</p>
                                    <p> This is used when the instruction is not available; a typical use</p>
                                    <p> case is to provision the cost of vectorization/scalarization in</p>
                                    <p> vectorizer passes.</p>
                                </div>
                                <p>Defined at line 1114 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="DE132AB4C8C2BDDE85E9A329504439633D1869E0">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getVectorInstrCost (unsigned int Opcode, Type * Val, TargetCostKind CostKind, unsigned int Index, Value * Scalar, ArrayRef&lt;std::tuple&lt;Value *, User *, int&gt;&gt; ScalarUserAndIdx)</code></pre>
                                <div>
                                    <h3>Parameters</h3>
                                    <div>
                                        <b>ScalarUserAndIdx</b>   encodes the information about extracts from a vector with &#39;Scalar&#39; being the value being extracted,&#39;User&#39; being the user of the extract(nullptr if user is not known before vectorization) and &#39;Idx&#39; being the extract lane.
                                    </div> 
                                    <h3>Returns</h3>
                                    <p> The expected cost of vector Insert and Extract.</p>
                                    <p> Use -1 to indicate that there is no information on the index value.</p>
                                    <p> This is used when the instruction is not available; a typical use</p>
                                    <p> case is to provision the cost of vectorization/scalarization in</p>
                                    <p> vectorizer passes.</p>
                                </div>
                                <p>Defined at line 1126 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="391080C6B59CDEA9C894E906CC62F598898FAEB3">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getVectorInstrCost (const Instruction &amp; I, Type * Val, TargetCostKind CostKind, unsigned int Index)</code></pre>
                                <div>
                                    <div>
                                        <p> A typical suitable use case is cost estimation when vector instruction</p>
                                        <p> exists (e.g., from basic blocks during transformation).</p>
                                    </div>
                                    <h3>Returns</h3>
                                    <p> The expected cost of vector Insert and Extract.</p>
                                    <p> This is used when instruction is available, and implementation</p>
                                    <p> asserts &#39;I&#39; is not nullptr.</p>
                                </div>
                                <p>Defined at line 1139 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="DF683F9E7F9E7FF68206358C04ACF1F96B7B6EF4">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getIndexedVectorInstrCostFromEnd (unsigned int Opcode, Type * Val, TargetCostKind CostKind, unsigned int Index)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The expected cost of inserting or extracting a lane that is </p>
                                    <p> elements from the end of a vector, i.e. the mathematical expression</p>
                                    <p> for the lane is (VF - 1 - Index). This is required for scalable vectors</p>
                                    <p> where the exact lane index is unknown at compile time.</p>
                                </div>
                                <p>Defined at line 1151 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8615DB92CB69E51EA35FB5227FCED66AB449956A">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getInsertExtractValueCost (unsigned int Opcode, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The expected cost of aggregate inserts and extracts. This is</p>
                                    <p> used when the instruction is not available; a typical use case is to</p>
                                    <p> provision the cost of vectorization/scalarization in vectorizer passes.</p>
                                </div>
                                <p>Defined at line 1160 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="21ADC7A8DE92474632BAEA0FD2998FD895A5771A">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getReplicationShuffleCost (Type * EltTy, int ReplicationFactor, int VF, const APInt &amp; DemandedDstElts, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> For example, the mask for </p>
                                        <p> and </p>
                                        <p> is:</p>
                                        <p>&lt;</p>
                                        <p>0,0,0,1,1,1,2,2,2,3,3,3&gt;</p>
                                    </div>
                                    <h3>Returns</h3>
                                    <p> The cost of replication shuffle of </p>
                                    <p> elements typed </p>
                                    <p> times.</p>
                                </div>
                                <p>Defined at line 1170 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="903670645B399E9DF1B68B9669617A60C7FBAA0A">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getMemoryOpCost (unsigned int Opcode, Type * Src, Align Alignment, unsigned int AddressSpace, TargetCostKind CostKind, OperandValueInfo OpdInfo, const Instruction * I)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The cost of Load and Store instructions. The operand info</p>
                                    <p> should refer to the stored value for stores and the address</p>
                                    <p> for loads.</p>
                                </div>
                                <p>Defined at line 1179 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0C14B57A6DDD4FFB23E28B4327699E0DE9387AB3">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getInterleavedMemoryOpCost (unsigned int Opcode, Type * VecTy, unsigned int Factor, ArrayRef Indices, Align Alignment, unsigned int AddressSpace, TargetCostKind CostKind, bool UseMaskForCond, bool UseMaskForGaps)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The cost of the interleaved memory operation.</p>
                                    <p> is the memory operation code</p>
                                    <p> is the vector type of the interleaved access.</p>
                                    <p> is the interleave factor</p>
                                    <p> is the indices for interleaved load members (as interleaved</p>
                                    <p>    load allows gaps)</p>
                                    <p> is the alignment of the memory operation</p>
                                    <p> is address space of the pointer.</p>
                                    <p> indicates if the memory access is predicated.</p>
                                    <p> indicates if gaps should be masked.</p>
                                </div>
                                <p>Defined at line 1191 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E2FD7BD5807BC22209DBBD94CFFCECDDF20938F6">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getArithmeticReductionCost (unsigned int Opcode, VectorType * Ty, optional FMF, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Calculate the cost of vector reduction intrinsics.</p>
                                    </div>
                                    <div>
                                        <p> This is the cost of reducing the vector value of type </p>
                                        <p> to a scalar</p>
                                        <p> value using the operation denoted by </p>
                                        <p> The FastMathFlags</p>
                                        <p> parameter </p>
                                        <p> indicates what type of reduction we are performing:</p>
                                        <p>   1. Tree-wise. This is the typical &#39;fast&#39; reduction performed that</p>
                                        <p>   involves successively splitting a vector into half and doing the</p>
                                        <p>   operation on the pair of halves until you have a scalar value. For</p>
                                        <p>   example:</p>
                                        <p>     (v0, v1, v2, v3)</p>
                                        <p>     ((v0+v2), (v1+v3), undef, undef)</p>
                                        <p>     ((v0+v2+v1+v3), undef, undef, undef)</p>
                                        <p>   This is the default behaviour for integer operations, whereas for</p>
                                        <p>   floating point we only do this if </p>
                                        <p> indicates that</p>
                                        <p>   reassociation is allowed.</p>
                                        <p>   2. Ordered. For a vector with N elements this involves performing N</p>
                                        <p>   operations in lane order, starting with an initial scalar value, i.e.</p>
                                        <p>     result = InitVal + v0</p>
                                        <p>     result = result + v1</p>
                                        <p>     result = result + v2</p>
                                        <p>     result = result + v3</p>
                                        <p>   This is only the case for FP operations and when reassociation is not</p>
                                        <p>   allowed.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1250 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="03FF1B644009274D0F465E3A08F018713825A2A9">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getMinMaxReductionCost (Intrinsic::ID IID, VectorType * Ty, FastMathFlags FMF, TargetCostKind CostKind)</code></pre>
                                <p>Defined at line 1259 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="C518E0FCA0FC11811DAC13B88379F794BE852015">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getMulAccReductionCost (bool IsUnsigned, unsigned int RedOpcode, Type * ResTy, VectorType * Ty, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Calculate the cost of an extended reduction pattern, similar to</p>
                                        <p> getArithmeticReductionCost of an Add/Sub reduction with multiply and</p>
                                        <p> optional extensions. This is the cost of as:</p>
                                        <p> * ResTy vecreduce.add/sub(mul (A, B)) or,</p>
                                        <p> * ResTy vecreduce.add/sub(mul(ext(Ty A), ext(Ty B)).</p>
                                    </div>
                                </div>
                                <p>Defined at line 1275 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="08E7AE2DCF83AB6ABB1A40E9AE17891DD9F7FB25">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getExtendedReductionCost (unsigned int Opcode, bool IsUnsigned, Type * ResTy, VectorType * Ty, optional FMF, TargetCostKind CostKind)</code></pre>
                                <div>
                                    <div>
                                        <p> Calculate the cost of an extended reduction pattern, similar to</p>
                                        <p> getArithmeticReductionCost of a reduction with an extension.</p>
                                        <p> This is the cost of as:</p>
                                        <p> ResTy vecreduce.opcode(ext(Ty A)).</p>
                                    </div>
                                </div>
                                <p>Defined at line 1268 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8FAD10B1D8E832206F1CC01256C6C60ADF794725">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getIntrinsicInstrCost (const IntrinsicCostAttributes &amp; ICA, TargetCostKind CostKind)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1202 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F287390D9ACE5442076B24DA46D6C7B0726C3A04">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getMemIntrinsicInstrCost (const MemIntrinsicCostAttributes &amp; MICA, TargetCostKind CostKind)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1210 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="658DB07807CDE2D30792594B6B432273FD87C326">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getCallInstrCost (Function * F, Type * RetTy, ArrayRef Tys, TargetCostKind CostKind)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1218 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="FD56C7D3B0CE350FE2EA92973D33E3EAE3D8028C">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getNumberOfParts (Type * Tp)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1227 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="D01721A374D169E36E670AE0AB385B4FF4B99CAC">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getAddressComputationCost (Type * PtrTy, ScalarEvolution * SE, const SCEV * Ptr, TargetCostKind CostKind)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1231 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="9BFB22324BE3494F47BE30AB6042DD912D2C64BC">
                                <pre><code class="language-cpp code-clang-doc">InstructionCost getCostOfKeepingLiveOverCall (ArrayRef Tys)</code></pre>
                                <div>
                                    <div>
                                        <p> Some types may require the use of register classes that do not have</p>
                                        <p> any callee-saved registers, so would require a spill and fill.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1282 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5E46BAE8455B464DF65788BAE737E94AD2C5C3F5">
                                <pre><code class="language-cpp code-clang-doc">bool getTgtMemIntrinsic (IntrinsicInst * Inst, MemIntrinsicInfo &amp; Info)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1287 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E4224B4C01ACE7973C7A3129B14532C18CE60C10">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getAtomicMemIntrinsicMaxElementSize ()</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1292 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="ADDD4AFC69D1CEB2D54C41680AEFC6B194B41AC6">
                                <pre><code class="language-cpp code-clang-doc">Value * getOrCreateResultFromMemIntrinsic (IntrinsicInst * Inst, Type * ExpectedType, bool CanCreate)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1296 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="94FC009BD541DEB6CCB2163F255F12FE07437C49">
                                <pre><code class="language-cpp code-clang-doc">Type * getMemcpyLoopLoweringType (LLVMContext &amp; Context, Value * Length, unsigned int SrcAddrSpace, unsigned int DestAddrSpace, Align SrcAlign, Align DestAlign, optional AtomicElementSize)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1302 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="DD71F483F2A72C34B30157F9804111E9E150E939">
                                <pre><code class="language-cpp code-clang-doc">void getMemcpyLoopResidualLoweringType (SmallVectorImpl&lt;Type *&gt; &amp; OpsOut, LLVMContext &amp; Context, unsigned int RemainingBytes, unsigned int SrcAddrSpace, unsigned int DestAddrSpace, Align SrcAlign, Align DestAlign, optional AtomicCpySize)</code></pre>
                                <div>
                                    <div>
                                        <p> Calculates the operand types to use when copying </p>
                                        <p> of</p>
                                        <p> memory, where source and destination alignments are </p>
                                        <p> and</p>
                                        <p> respectively.</p>
                                    </div>
                                    <h3>Parameters</h3>
                                    <div>
                                        <b>OpsOut</b> [out]  The operand types to copy RemainingBytes of memory.
                                    </div> 
                                    <div>
                                        <b>RemainingBytes</b>   The number of bytes to copy.
                                    </div> 
                                </div>
                                <p>Defined at line 1311 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="704617D6EE74316D86F3AB222FD5BFF2AA6C98E4">
                                <pre><code class="language-cpp code-clang-doc">bool areInlineCompatible (const Function * Caller, const Function * Callee)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1321 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2665D13986D3A9B09121D1BE2D4D3C25085A264B">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getInlineCallPenalty (const Function * F, const CallBase &amp; Call, unsigned int DefaultCallPenalty)</code></pre>
                                <div>
                                    <div>
                                        <p> Returns a penalty for invoking call </p>
                                        <p> in </p>
                                        <p> For example, if a function F calls a function G, which in turn calls</p>
                                        <p> function H, then getInlineCallPenalty(F, H()) would return the</p>
                                        <p> penalty of calling H from F, e.g. after inlining G into F.</p>
                                        <p> is passed to give a default penalty that</p>
                                        <p> the target can amend or override.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1326 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="AFCE8B492666E055081058580E7A646C83491ACE">
                                <pre><code class="language-cpp code-clang-doc">bool areTypesABICompatible (const Function * Caller, const Function * Callee, ArrayRef Types)</code></pre>
                                <div>
                                    <h3>Parameters</h3>
                                    <div>
                                        <b>Types</b>   List of types to check.
                                    </div> 
                                </div>
                                <p>Defined at line 1333 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="A3B3A8FA027BB25A24C812343EDACEF7F5698799">
                                <pre><code class="language-cpp code-clang-doc">bool isIndexedLoadLegal (MemIndexedMode Mode, Type * Ty)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1339 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8F0A641F9A319454B0DC2F21AF81AFF6DF8F2B14">
                                <pre><code class="language-cpp code-clang-doc">bool isIndexedStoreLegal (MemIndexedMode Mode, Type * Ty)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1344 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6E951F4C6F456BCA9326B1192DEABD434832A418">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getLoadStoreVecRegBitWidth (unsigned int AddrSpace)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1349 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="9B6E99CA89AEF21B073DF25AC1ED0640ADC478B8">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalToVectorizeLoad (LoadInst * LI)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1353 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="BDA308B11F7AB40E0C2A7066555237010FA439B9">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalToVectorizeStore (StoreInst * SI)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1357 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2C9B075C3C8C66AC8ADA91A17791F63183F9435A">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalToVectorizeLoadChain (unsigned int ChainSizeInBytes, Align Alignment, unsigned int AddrSpace)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1361 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="7F96DC2A5DC76356436E32CD1FE4C75DC9BE0F99">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalToVectorizeStoreChain (unsigned int ChainSizeInBytes, Align Alignment, unsigned int AddrSpace)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1367 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="EA19F3F58026227E89961F301B797C032B950EA6">
                                <pre><code class="language-cpp code-clang-doc">bool isLegalToVectorizeReduction (const RecurrenceDescriptor &amp; RdxDesc, ElementCount VF)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1373 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5EE65F4DC8F45FB8509082CDB4F79FFE33B3B129">
                                <pre><code class="language-cpp code-clang-doc">bool isElementTypeLegalForScalableVector (Type * Ty)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1378 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1FC5AC54470A818945DFB36FD6B979EC7EAE6523">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getLoadVectorFactor (unsigned int VF, unsigned int LoadSize, unsigned int ChainSizeInBytes, VectorType * VecTy)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1382 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="064D8917CA118FF46903E8D05A4A55547F0CB6E4">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getStoreVectorFactor (unsigned int VF, unsigned int StoreSize, unsigned int ChainSizeInBytes, VectorType * VecTy)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1389 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="E8FF2DCE11CCDD93B495AAB80FF4D5D6A5979D96">
                                <pre><code class="language-cpp code-clang-doc">bool preferFixedOverScalableIfEqualCost (bool IsEpilogue)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1396 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8FDC546DA05FFB77BC78F1ECFB4A13E121DDA019">
                                <pre><code class="language-cpp code-clang-doc">bool preferAlternateOpcodeVectorization ()</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1406 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="263EEAAB8482A7EEAC082C9783E3CC8DB1BB0060">
                                <pre><code class="language-cpp code-clang-doc">bool preferInLoopReduction (RecurKind Kind, Type * Ty)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1401 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="9380F5E5195E0601172504E608847804FA911E19">
                                <pre><code class="language-cpp code-clang-doc">bool preferPredicatedReductionSelect ()</code></pre>
                                <div>
                                    <div>
                                        <p> As opposed to the normal scheme of p = phi (0, a) which allows the select</p>
                                        <p> to be pulled out of the loop. If the select(.., add, ..) can be predicated</p>
                                        <p> by the target, this can lead to cleaner code generation.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1410 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="6BBFD6D88D282ACC1E10D7FCB37A43202F0AC2EA">
                                <pre><code class="language-cpp code-clang-doc">bool preferEpilogueVectorization ()</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if the loop vectorizer should consider vectorizing an</p>
                                        <p> otherwise scalar epilogue loop.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1414 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="AD56A2032ED723728C53FB8D78EA9BE220AEC923">
                                <pre><code class="language-cpp code-clang-doc">bool shouldConsiderVectorizationRegPressure ()</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1418 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="527B858A4ECD93E0F3D8500E7D79791C974D1E3D">
                                <pre><code class="language-cpp code-clang-doc">bool shouldExpandReduction (const IntrinsicInst * II)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1447 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="4BAC0D8658471BA901424693461C22CAEB0D46C4">
                                <pre><code class="language-cpp code-clang-doc">ReductionShuffle getPreferredExpandedReductionShuffle (const IntrinsicInst * II)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1451 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="2999B6BA2194D98ED1B87A0B561F24F3B71980A0">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getGISelRematGlobalCost ()</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1457 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="7147B4A94F8A66FAA7A884AAA96E3C40532D52C8">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getMinTripCountTailFoldingThreshold ()</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1461 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8FDCA26DCF30EFF51EB495CA159EE75771D3256A">
                                <pre><code class="language-cpp code-clang-doc">bool supportsScalableVectors ()</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1465 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="FBBD3B4C4A0A4774C9392A943ADA467961F0AA4B">
                                <pre><code class="language-cpp code-clang-doc">bool enableScalableVectorization ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> true when scalable vectorization is preferred.</p>
                                </div>
                                <p>Defined at line 1469 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="CC3476656024B34576DE7F53729894F6B850C270">
                                <pre><code class="language-cpp code-clang-doc">bool hasActiveVectorLength ()</code></pre>
                                <div>
                                    <div>
                                        <p>@</p>
                                        <p>{</p>
                                        <p> Whether the target supports the %evl parameter of VP intrinsic efficiently</p>
                                        <p> in hardware. (see LLVM Language Reference - &quot;Vector Predication</p>
                                        <p> Intrinsics&quot;). Use of %evl is discouraged when that is not the case.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1473 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="1E0206FE465EFA5775DCE6906C134BC68986D4FC">
                                <pre><code class="language-cpp code-clang-doc">bool isProfitableToSinkOperands (Instruction * I, SmallVectorImpl&lt;Use *&gt; &amp; Ops)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if sinking I&#39;s operands to the same basic block as I is</p>
                                        <p> profitable, e.g. because the operands can be folded into a target</p>
                                        <p> instruction during instruction selection. After calling the function</p>
                                        <p> contains the Uses to sink ordered by dominance (dominating users</p>
                                        <p> come first).</p>
                                    </div>
                                </div>
                                <p>Defined at line 1477 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F806C2B48BF02E8A6035ED97BAC3CDE85C46B371">
                                <pre><code class="language-cpp code-clang-doc">bool isVectorShiftByScalarCheap (Type * Ty)</code></pre>
                                <div>
                                    <div>
                                        <p> Return true if it&#39;s significantly cheaper to shift a vector by a uniform</p>
                                        <p> scalar than by an amount which will vary across each lane. On x86 before</p>
                                        <p> AVX2 for example, there is a &quot;psllw&quot; instruction for the former case, but</p>
                                        <p> no simple instruction for a general &quot;a &lt;&lt; b&quot; operation on vectors.</p>
                                        <p> This should also apply to lowering for vector funnel shifts (rotates).</p>
                                    </div>
                                </div>
                                <p>Defined at line 1482 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="F8F19A504552B9C02269253B383C508AC45D47D7">
                                <pre><code class="language-cpp code-clang-doc">VPLegalization getVPLegalizationStrategy (const VPIntrinsic &amp; PI)</code></pre>
                                <div>
                                </div>
                                <p>Defined at line 1422 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="66DB612FF20C861EC5331FE69C5F5015D5650E32">
                                <pre><code class="language-cpp code-clang-doc">bool hasArmWideBranch (bool Thumb)</code></pre>
                                <div>
                                    <div>
                                        <p> Used by the LowerTypeTests pass, which constructs an IR inline assembler</p>
                                        <p> node containing a jump table in a format suitable for the target, so it</p>
                                        <p> needs to know what format of jump table it can legally use.</p>
                                    </div>
                                    <div>
                                        <p> For non-Arm targets, this function isn&#39;t used. It defaults to returning</p>
                                        <p> false, but it shouldn&#39;t matter what it returns anyway.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1427 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="D34677A261AB9B885304EA45B1E04DF1DA78DD2F">
                                <pre><code class="language-cpp code-clang-doc">APInt getFeatureMask (const Function &amp; F)</code></pre>
                                <div>
                                    <div>
                                        <p> Returns a bitmask constructed from the target-features or fmv-features</p>
                                        <p> metadata of a function corresponding to its Arch Extensions.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1431 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="8A8C31C78C2D4D930ECA19CE9CE12F0DC3154424">
                                <pre><code class="language-cpp code-clang-doc">APInt getPriorityMask (const Function &amp; F)</code></pre>
                                <div>
                                    <div>
                                        <p> Returns a bitmask constructed from the target-features or fmv-features</p>
                                        <p> metadata of a function corresponding to its FMV priority.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1435 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="58A8415E1FA8BB146161AEEC9B233D6B818D6D08">
                                <pre><code class="language-cpp code-clang-doc">bool isMultiversionedFunction (const Function &amp; F)</code></pre>
                                <div>
                                    <div>
                                        <p> Returns true if this is an instance of a function with multiple versions.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1439 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="5359608573B28FE801D8730C2D99933307D1CF8A">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getMaxNumArgs ()</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> The maximum number of function arguments the target supports.</p>
                                </div>
                                <p>Defined at line 1443 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0EE88686E02E5AD75D6B0F3F14C31D61FE55CE05">
                                <pre><code class="language-cpp code-clang-doc">unsigned int getNumBytesToPadGlobalArray (unsigned int Size, Type * ArrayType)</code></pre>
                                <div>
                                    <h3>Returns</h3>
                                    <p> For an array of given Size, return alignment boundary to</p>
                                    <p> pad to. Default is no padding.</p>
                                </div>
                                <p>Defined at line 1486 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="CFAB00E090E5DA7780BE0C0E6EEB54EA281B00B3">
                                <pre><code class="language-cpp code-clang-doc">void collectKernelLaunchBounds (const Function &amp; F, SmallVectorImpl&lt;std::pair&lt;StringRef, int64_t&gt;&gt; &amp; LB)</code></pre>
                                <div>
                                    <div>
                                        <p> Collect kernel launch bounds for </p>
                                        <p> into </p>
                                    </div>
                                </div>
                                <p>Defined at line 1492 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="AA79A686107FB6DC2EFAB082CB2EEA846E57C2F8">
                                <pre><code class="language-cpp code-clang-doc">bool allowVectorElementIndexingUsingGEP ()</code></pre>
                                <div>
                                    <div>
                                        <p> Returns true if GEP should not be used to index into vectors for this</p>
                                        <p> target.</p>
                                    </div>
                                </div>
                                <p>Defined at line 1498 of file llvm/lib/Analysis/TargetTransformInfo.cpp</p>
                            </div>
                        </div>
                        <div class="delimiter-container">
                            <div id="0205C61D21F889FCF09E710BAD514EEC43C9114A">
                                <pre><code class="language-cpp code-clang-doc">bool requiresOrderedReduction (optional FMF)</code></pre>
                                <div>
                                    <div>
                                        <p> A helper function to determine the type of reduction algorithm used</p>
                                        <p> for a given </p>
                                        <p> and set of FastMathFlags </p>
                                    </div>
                                </div>
                                <p>Defined at line 1640 of file llvm/include/llvm/Analysis/TargetTransformInfo.h</p>
                            </div>
                        </div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
                <section id="Enums" class="section-container">
                    <h2>Enumerations</h2>
                    <div>
                    </div>
                </section>
            </div>
        </div>
    </main>
</body>
</html>

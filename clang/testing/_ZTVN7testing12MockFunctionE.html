<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8"/>
    <title>MockFunction</title>
        <link rel="stylesheet" type="text/css" href="../clang-doc-mustache.css"/>
        <script src="../mustache-index.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="navbar__container">
            <div class="navbar__logo">
                
            </div>
            <div class="navbar__menu">
                <ul class="navbar__links">
                    <li class="navbar__item">
                        <a href="../index.html" class="navbar__link">Home</a>
                    </li>
                </ul>
            </div>
            <div class="navbar-breadcrumb-container">
                <div class="navbar-breadcrumb-item"><a href="../GlobalNamespace/index.html">Global Namespace</a></div>&rarr;
                <div class="navbar-breadcrumb-item"><a href="./index.html">testing</a></div>
            </div>
        </div>
    </nav>
    <main>
        <div class="container">
            <div class="sidebar">
                <h2>class MockFunction</h2>
                <ul>
                </ul>
            </div>
            <div class="resizer" id="resizer"></div>
            <div class="content">
                <section class="hero section-container">
                    <pre><code class="language-cpp code-clang-doc">template &lt;typename F&gt;</code></pre>
                    <div class="hero__title">
                        <h1 class="hero__title-large">class MockFunction</h1>
                        <p>Defined at line 2033 of file third-party/unittest/googlemock/include/gmock/gmock-spec-builders.h</p>
                        <div class="hero__subtitle">
                            <div>
                                <p> A MockFunction</p>
                                <p>&lt;F</p>
                                <p>&gt; type has one mock method whose type is</p>
                                <p> internal::SignatureOfT</p>
                                <p>&lt;F</p>
                                <p>&gt;.  It is useful when you just want your</p>
                                <p> test code to emit some messages and have Google Mock verify the</p>
                                <p> right messages are sent (and perhaps at the right times).  For</p>
                                <p> example, if you are exercising code:</p>
                            </div>
                            <div>
                                <p>   Foo(1);</p>
                                <p>   Foo(2);</p>
                                <p>   Foo(3);</p>
                            </div>
                            <div>
                                <p> and want to verify that Foo(1) and Foo(3) both invoke</p>
                                <p> mock.Bar(&quot;a&quot;), but Foo(2) doesn&#39;t invoke anything, you can write:</p>
                            </div>
                            <div>
                                <p> TEST(FooTest, InvokesBarCorrectly) {</p>
                                <p>   MyMock mock;</p>
                                <p>   MockFunction</p>
                                <p>&lt;void</p>
                                <p>(string check_point_name)&gt; check;</p>
                                <p>   {</p>
                                <p>     InSequence s;</p>
                            </div>
                            <div>
                                <p>     EXPECT_CALL(mock, Bar(&quot;a&quot;));</p>
                                <p>     EXPECT_CALL(check, Call(&quot;1&quot;));</p>
                                <p>     EXPECT_CALL(check, Call(&quot;2&quot;));</p>
                                <p>     EXPECT_CALL(mock, Bar(&quot;a&quot;));</p>
                                <p>   }</p>
                                <p>   Foo(1);</p>
                                <p>   check.Call(&quot;1&quot;);</p>
                                <p>   Foo(2);</p>
                                <p>   check.Call(&quot;2&quot;);</p>
                                <p>   Foo(3);</p>
                                <p> }</p>
                            </div>
                            <div>
                                <p> The expectation spec says that the first Bar(&quot;a&quot;) must happen</p>
                                <p> before check point &quot;1&quot;, the second Bar(&quot;a&quot;) must happen after check</p>
                                <p> point &quot;2&quot;, and nothing should happen between the two check</p>
                                <p> points. The explicit check points make it easy to tell which</p>
                                <p> Bar(&quot;a&quot;) is called by which call to Foo().</p>
                            </div>
                            <div>
                                <p> MockFunction</p>
                                <p>&lt;F</p>
                                <p>&gt; can also be used to exercise code that accepts</p>
                                <p> std::function</p>
                                <p>&lt;internal</p>
                                <p>::SignatureOfT</p>
                                <p>&lt;F</p>
                                <p>&gt;&gt; callbacks. To do so, use</p>
                                <p> AsStdFunction() method to create std::function proxy forwarding to</p>
                                <p> original object&#39;s Call. Example:</p>
                            </div>
                            <div>
                                <p> TEST(FooTest, RunsCallbackWithBarArgument) {</p>
                                <p>   MockFunction</p>
                                <p>&lt;int</p>
                                <p>(string)&gt; callback;</p>
                                <p>   EXPECT_CALL(callback, Call(&quot;bar&quot;)).WillOnce(Return(1));</p>
                                <p>   Foo(callback.AsStdFunction());</p>
                                <p> }</p>
                            </div>
                            <div>
                                <p> The internal::SignatureOfT</p>
                                <p>&lt;F</p>
                                <p>&gt; indirection allows to use other types</p>
                                <p> than just function signature type. This is typically useful when</p>
                                <p> providing a mock for a predefined std::function type. Example:</p>
                            </div>
                            <div>
                                <p> using FilterPredicate = std::function</p>
                                <p>&lt;bool</p>
                                <p>(string)&gt;;</p>
                                <p> void MyFilterAlgorithm(FilterPredicate predicate);</p>
                            </div>
                            <div>
                                <p> TEST(FooTest, FilterPredicateAlwaysAccepts) {</p>
                                <p>   MockFunction</p>
                                <p>&lt;FilterPredicate</p>
                                <p>&gt; predicateMock;</p>
                                <p>   EXPECT_CALL(predicateMock, Call(_)).WillRepeatedly(Return(true));</p>
                                <p>   MyFilterAlgorithm(predicateMock.AsStdFunction());</p>
                                <p> }</p>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </main>
</body>
</html>
